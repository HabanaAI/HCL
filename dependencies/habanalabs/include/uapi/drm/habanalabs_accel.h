/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
 *
 * Copyright 2016-2023 HabanaLabs, Ltd.
 * All Rights Reserved.
 *
 */

#ifndef HABANALABS_H_
#define HABANALABS_H_

#include <linux/if_ether.h>

#ifdef __KERNEL__
#include <drm/drm.h>
#else
#include "drm.h"
#endif

/*
 * Defines that are asic-specific but constitutes as ABI between kernel driver
 * and userspace
 */
#define GOYA_KMD_SRAM_RESERVED_SIZE_FROM_START		0x8000	/* 32KB */
#define GAUDI_DRIVER_SRAM_RESERVED_SIZE_FROM_START	0x80	/* 128 bytes */
#define GRECO_DRIVER_SRAM_RESERVED_SIZE_FROM_START	0x80	/* 128 bytes */

/*
 * 128 SOBs reserved for collective wait
 * 16 SOBs reserved for sync stream
 */
#define GAUDI_FIRST_AVAILABLE_W_S_SYNC_OBJECT		144

/*
 * 64 monitors reserved for collective wait
 * 8 monitors reserved for sync stream
 */
#define GAUDI_FIRST_AVAILABLE_W_S_MONITOR		72

/*
 * 64 SOBs reserved for completion Q
 * 1 SOB reserved for KDMA completion
 * 32 SOBs reserved for sync stream
 */
#define GRECO_FIRST_AVAILABLE_SYNC_OBJECT		97

/*
 * 64 monitors reserved for completion Q
 * 16 monitors reserved for sync stream
 */
#define GRECO_FIRST_AVAILABLE_MONITOR			80

/* Max number of elements in timestamps registration buffers */
#define	TS_MAX_ELEMENTS_NUM				(1 << 20) /* 1MB */

/*
 * Goya queue Numbering
 *
 * The external queues (PCI DMA channels) MUST be before the internal queues
 * and each group (PCI DMA channels and internal) must be contiguous inside
 * itself but there can be a gap between the two groups (although not
 * recommended)
 */

enum goya_queue_id {
	GOYA_QUEUE_ID_DMA_0 = 0,
	GOYA_QUEUE_ID_DMA_1 = 1,
	GOYA_QUEUE_ID_DMA_2 = 2,
	GOYA_QUEUE_ID_DMA_3 = 3,
	GOYA_QUEUE_ID_DMA_4 = 4,
	GOYA_QUEUE_ID_CPU_PQ = 5,
	GOYA_QUEUE_ID_MME = 6,	/* Internal queues start here */
	GOYA_QUEUE_ID_TPC0 = 7,
	GOYA_QUEUE_ID_TPC1 = 8,
	GOYA_QUEUE_ID_TPC2 = 9,
	GOYA_QUEUE_ID_TPC3 = 10,
	GOYA_QUEUE_ID_TPC4 = 11,
	GOYA_QUEUE_ID_TPC5 = 12,
	GOYA_QUEUE_ID_TPC6 = 13,
	GOYA_QUEUE_ID_TPC7 = 14,
	GOYA_QUEUE_ID_SIZE
};

/*
 * Gaudi queue Numbering
 * External queues (PCI DMA channels) are DMA_0_*, DMA_1_* and DMA_5_*.
 * Except one CPU queue, all the rest are internal queues.
 */

enum gaudi_queue_id {
	GAUDI_QUEUE_ID_DMA_0_0 = 0,	/* external */
	GAUDI_QUEUE_ID_DMA_0_1 = 1,	/* external */
	GAUDI_QUEUE_ID_DMA_0_2 = 2,	/* external */
	GAUDI_QUEUE_ID_DMA_0_3 = 3,	/* external */
	GAUDI_QUEUE_ID_DMA_1_0 = 4,	/* external */
	GAUDI_QUEUE_ID_DMA_1_1 = 5,	/* external */
	GAUDI_QUEUE_ID_DMA_1_2 = 6,	/* external */
	GAUDI_QUEUE_ID_DMA_1_3 = 7,	/* external */
	GAUDI_QUEUE_ID_CPU_PQ = 8,	/* CPU */
	GAUDI_QUEUE_ID_DMA_2_0 = 9,	/* internal */
	GAUDI_QUEUE_ID_DMA_2_1 = 10,	/* internal */
	GAUDI_QUEUE_ID_DMA_2_2 = 11,	/* internal */
	GAUDI_QUEUE_ID_DMA_2_3 = 12,	/* internal */
	GAUDI_QUEUE_ID_DMA_3_0 = 13,	/* internal */
	GAUDI_QUEUE_ID_DMA_3_1 = 14,	/* internal */
	GAUDI_QUEUE_ID_DMA_3_2 = 15,	/* internal */
	GAUDI_QUEUE_ID_DMA_3_3 = 16,	/* internal */
	GAUDI_QUEUE_ID_DMA_4_0 = 17,	/* internal */
	GAUDI_QUEUE_ID_DMA_4_1 = 18,	/* internal */
	GAUDI_QUEUE_ID_DMA_4_2 = 19,	/* internal */
	GAUDI_QUEUE_ID_DMA_4_3 = 20,	/* internal */
	GAUDI_QUEUE_ID_DMA_5_0 = 21,	/* internal */
	GAUDI_QUEUE_ID_DMA_5_1 = 22,	/* internal */
	GAUDI_QUEUE_ID_DMA_5_2 = 23,	/* internal */
	GAUDI_QUEUE_ID_DMA_5_3 = 24,	/* internal */
	GAUDI_QUEUE_ID_DMA_6_0 = 25,	/* internal */
	GAUDI_QUEUE_ID_DMA_6_1 = 26,	/* internal */
	GAUDI_QUEUE_ID_DMA_6_2 = 27,	/* internal */
	GAUDI_QUEUE_ID_DMA_6_3 = 28,	/* internal */
	GAUDI_QUEUE_ID_DMA_7_0 = 29,	/* internal */
	GAUDI_QUEUE_ID_DMA_7_1 = 30,	/* internal */
	GAUDI_QUEUE_ID_DMA_7_2 = 31,	/* internal */
	GAUDI_QUEUE_ID_DMA_7_3 = 32,	/* internal */
	GAUDI_QUEUE_ID_MME_0_0 = 33,	/* internal */
	GAUDI_QUEUE_ID_MME_0_1 = 34,	/* internal */
	GAUDI_QUEUE_ID_MME_0_2 = 35,	/* internal */
	GAUDI_QUEUE_ID_MME_0_3 = 36,	/* internal */
	GAUDI_QUEUE_ID_MME_1_0 = 37,	/* internal */
	GAUDI_QUEUE_ID_MME_1_1 = 38,	/* internal */
	GAUDI_QUEUE_ID_MME_1_2 = 39,	/* internal */
	GAUDI_QUEUE_ID_MME_1_3 = 40,	/* internal */
	GAUDI_QUEUE_ID_TPC_0_0 = 41,	/* internal */
	GAUDI_QUEUE_ID_TPC_0_1 = 42,	/* internal */
	GAUDI_QUEUE_ID_TPC_0_2 = 43,	/* internal */
	GAUDI_QUEUE_ID_TPC_0_3 = 44,	/* internal */
	GAUDI_QUEUE_ID_TPC_1_0 = 45,	/* internal */
	GAUDI_QUEUE_ID_TPC_1_1 = 46,	/* internal */
	GAUDI_QUEUE_ID_TPC_1_2 = 47,	/* internal */
	GAUDI_QUEUE_ID_TPC_1_3 = 48,	/* internal */
	GAUDI_QUEUE_ID_TPC_2_0 = 49,	/* internal */
	GAUDI_QUEUE_ID_TPC_2_1 = 50,	/* internal */
	GAUDI_QUEUE_ID_TPC_2_2 = 51,	/* internal */
	GAUDI_QUEUE_ID_TPC_2_3 = 52,	/* internal */
	GAUDI_QUEUE_ID_TPC_3_0 = 53,	/* internal */
	GAUDI_QUEUE_ID_TPC_3_1 = 54,	/* internal */
	GAUDI_QUEUE_ID_TPC_3_2 = 55,	/* internal */
	GAUDI_QUEUE_ID_TPC_3_3 = 56,	/* internal */
	GAUDI_QUEUE_ID_TPC_4_0 = 57,	/* internal */
	GAUDI_QUEUE_ID_TPC_4_1 = 58,	/* internal */
	GAUDI_QUEUE_ID_TPC_4_2 = 59,	/* internal */
	GAUDI_QUEUE_ID_TPC_4_3 = 60,	/* internal */
	GAUDI_QUEUE_ID_TPC_5_0 = 61,	/* internal */
	GAUDI_QUEUE_ID_TPC_5_1 = 62,	/* internal */
	GAUDI_QUEUE_ID_TPC_5_2 = 63,	/* internal */
	GAUDI_QUEUE_ID_TPC_5_3 = 64,	/* internal */
	GAUDI_QUEUE_ID_TPC_6_0 = 65,	/* internal */
	GAUDI_QUEUE_ID_TPC_6_1 = 66,	/* internal */
	GAUDI_QUEUE_ID_TPC_6_2 = 67,	/* internal */
	GAUDI_QUEUE_ID_TPC_6_3 = 68,	/* internal */
	GAUDI_QUEUE_ID_TPC_7_0 = 69,	/* internal */
	GAUDI_QUEUE_ID_TPC_7_1 = 70,	/* internal */
	GAUDI_QUEUE_ID_TPC_7_2 = 71,	/* internal */
	GAUDI_QUEUE_ID_TPC_7_3 = 72,	/* internal */
	GAUDI_QUEUE_ID_NIC_0_0 = 73,	/* internal */
	GAUDI_QUEUE_ID_NIC_0_1 = 74,	/* internal */
	GAUDI_QUEUE_ID_NIC_0_2 = 75,	/* internal */
	GAUDI_QUEUE_ID_NIC_0_3 = 76,	/* internal */
	GAUDI_QUEUE_ID_NIC_1_0 = 77,	/* internal */
	GAUDI_QUEUE_ID_NIC_1_1 = 78,	/* internal */
	GAUDI_QUEUE_ID_NIC_1_2 = 79,	/* internal */
	GAUDI_QUEUE_ID_NIC_1_3 = 80,	/* internal */
	GAUDI_QUEUE_ID_NIC_2_0 = 81,	/* internal */
	GAUDI_QUEUE_ID_NIC_2_1 = 82,	/* internal */
	GAUDI_QUEUE_ID_NIC_2_2 = 83,	/* internal */
	GAUDI_QUEUE_ID_NIC_2_3 = 84,	/* internal */
	GAUDI_QUEUE_ID_NIC_3_0 = 85,	/* internal */
	GAUDI_QUEUE_ID_NIC_3_1 = 86,	/* internal */
	GAUDI_QUEUE_ID_NIC_3_2 = 87,	/* internal */
	GAUDI_QUEUE_ID_NIC_3_3 = 88,	/* internal */
	GAUDI_QUEUE_ID_NIC_4_0 = 89,	/* internal */
	GAUDI_QUEUE_ID_NIC_4_1 = 90,	/* internal */
	GAUDI_QUEUE_ID_NIC_4_2 = 91,	/* internal */
	GAUDI_QUEUE_ID_NIC_4_3 = 92,	/* internal */
	GAUDI_QUEUE_ID_NIC_5_0 = 93,	/* internal */
	GAUDI_QUEUE_ID_NIC_5_1 = 94,	/* internal */
	GAUDI_QUEUE_ID_NIC_5_2 = 95,	/* internal */
	GAUDI_QUEUE_ID_NIC_5_3 = 96,	/* internal */
	GAUDI_QUEUE_ID_NIC_6_0 = 97,	/* internal */
	GAUDI_QUEUE_ID_NIC_6_1 = 98,	/* internal */
	GAUDI_QUEUE_ID_NIC_6_2 = 99,	/* internal */
	GAUDI_QUEUE_ID_NIC_6_3 = 100,	/* internal */
	GAUDI_QUEUE_ID_NIC_7_0 = 101,	/* internal */
	GAUDI_QUEUE_ID_NIC_7_1 = 102,	/* internal */
	GAUDI_QUEUE_ID_NIC_7_2 = 103,	/* internal */
	GAUDI_QUEUE_ID_NIC_7_3 = 104,	/* internal */
	GAUDI_QUEUE_ID_NIC_8_0 = 105,	/* internal */
	GAUDI_QUEUE_ID_NIC_8_1 = 106,	/* internal */
	GAUDI_QUEUE_ID_NIC_8_2 = 107,	/* internal */
	GAUDI_QUEUE_ID_NIC_8_3 = 108,	/* internal */
	GAUDI_QUEUE_ID_NIC_9_0 = 109,	/* internal */
	GAUDI_QUEUE_ID_NIC_9_1 = 110,	/* internal */
	GAUDI_QUEUE_ID_NIC_9_2 = 111,	/* internal */
	GAUDI_QUEUE_ID_NIC_9_3 = 112,	/* internal */
	GAUDI_QUEUE_ID_SIZE
};

/*
 * In GRECO, we have two modes of operation:
 * - Full-Chip, where two DCOREs are used by a single user at the same time
 * - Half-Chip, where each DCORE is used by a different user
 *
 * Therefore, the queue ids should represent the two modes. In Full-Chip mode,
 * all queue ids are valid and in Half-Chip mode, only DCORE0 queue ids are
 * valid
 */
enum greco_queue_id {
	GRECO_QUEUE_ID_DCORE0_PDMA_0_0 = 0,
	GRECO_QUEUE_ID_DCORE0_PDMA_0_1 = 1,
	GRECO_QUEUE_ID_DCORE0_PDMA_0_2 = 2,
	GRECO_QUEUE_ID_DCORE0_PDMA_0_3 = 3,
	GRECO_QUEUE_ID_DCORE0_PDMA_1_0 = 4,
	GRECO_QUEUE_ID_DCORE0_PDMA_1_1 = 5,
	GRECO_QUEUE_ID_DCORE0_PDMA_1_2 = 6,
	GRECO_QUEUE_ID_DCORE0_PDMA_1_3 = 7,
	GRECO_QUEUE_ID_DCORE0_DDMA_0_0 = 8,
	GRECO_QUEUE_ID_DCORE0_DDMA_0_1 = 9,
	GRECO_QUEUE_ID_DCORE0_DDMA_0_2 = 10,
	GRECO_QUEUE_ID_DCORE0_DDMA_0_3 = 11,
	GRECO_QUEUE_ID_DCORE0_MME_0_0 = 12,
	GRECO_QUEUE_ID_DCORE0_MME_0_1 = 13,
	GRECO_QUEUE_ID_DCORE0_MME_0_2 = 14,
	GRECO_QUEUE_ID_DCORE0_MME_0_3 = 15,
	GRECO_QUEUE_ID_DCORE0_TPC_0_0 = 16,
	GRECO_QUEUE_ID_DCORE0_TPC_0_1 = 17,
	GRECO_QUEUE_ID_DCORE0_TPC_0_2 = 18,
	GRECO_QUEUE_ID_DCORE0_TPC_0_3 = 19,
	GRECO_QUEUE_ID_DCORE0_TPC_1_0 = 20,
	GRECO_QUEUE_ID_DCORE0_TPC_1_1 = 21,
	GRECO_QUEUE_ID_DCORE0_TPC_1_2 = 22,
	GRECO_QUEUE_ID_DCORE0_TPC_1_3 = 23,
	GRECO_QUEUE_ID_DCORE0_TPC_2_0 = 24,
	GRECO_QUEUE_ID_DCORE0_TPC_2_1 = 25,
	GRECO_QUEUE_ID_DCORE0_TPC_2_2 = 26,
	GRECO_QUEUE_ID_DCORE0_TPC_2_3 = 27,
	GRECO_QUEUE_ID_DCORE0_TPC_3_0 = 28,
	GRECO_QUEUE_ID_DCORE0_TPC_3_1 = 29,
	GRECO_QUEUE_ID_DCORE0_TPC_3_2 = 30,
	GRECO_QUEUE_ID_DCORE0_TPC_3_3 = 31,
	GRECO_QUEUE_ID_DCORE0_TPC_4_0 = 32,
	GRECO_QUEUE_ID_DCORE0_TPC_4_1 = 33,
	GRECO_QUEUE_ID_DCORE0_TPC_4_2 = 34,
	GRECO_QUEUE_ID_DCORE0_TPC_4_3 = 35,
	GRECO_QUEUE_ID_DCORE0_ROT_0_0 = 36,
	GRECO_QUEUE_ID_DCORE0_ROT_0_1 = 37,
	GRECO_QUEUE_ID_DCORE0_ROT_0_2 = 38,
	GRECO_QUEUE_ID_DCORE0_ROT_0_3 = 39,
	GRECO_QUEUE_ID_DCORE1_PDMA_0_0 = 40,
	GRECO_QUEUE_ID_DCORE1_PDMA_0_1 = 41,
	GRECO_QUEUE_ID_DCORE1_PDMA_0_2 = 42,
	GRECO_QUEUE_ID_DCORE1_PDMA_0_3 = 43,
	GRECO_QUEUE_ID_DCORE1_PDMA_1_0 = 44,
	GRECO_QUEUE_ID_DCORE1_PDMA_1_1 = 45,
	GRECO_QUEUE_ID_DCORE1_PDMA_1_2 = 46,
	GRECO_QUEUE_ID_DCORE1_PDMA_1_3 = 47,
	GRECO_QUEUE_ID_DCORE1_DDMA_0_0 = 48,
	GRECO_QUEUE_ID_DCORE1_DDMA_0_1 = 49,
	GRECO_QUEUE_ID_DCORE1_DDMA_0_2 = 50,
	GRECO_QUEUE_ID_DCORE1_DDMA_0_3 = 51,
	GRECO_QUEUE_ID_DCORE1_MME_0_0 = 52,
	GRECO_QUEUE_ID_DCORE1_MME_0_1 = 53,
	GRECO_QUEUE_ID_DCORE1_MME_0_2 = 54,
	GRECO_QUEUE_ID_DCORE1_MME_0_3 = 55,
	GRECO_QUEUE_ID_DCORE1_TPC_0_0 = 56,
	GRECO_QUEUE_ID_DCORE1_TPC_0_1 = 57,
	GRECO_QUEUE_ID_DCORE1_TPC_0_2 = 58,
	GRECO_QUEUE_ID_DCORE1_TPC_0_3 = 59,
	GRECO_QUEUE_ID_DCORE1_TPC_1_0 = 60,
	GRECO_QUEUE_ID_DCORE1_TPC_1_1 = 61,
	GRECO_QUEUE_ID_DCORE1_TPC_1_2 = 62,
	GRECO_QUEUE_ID_DCORE1_TPC_1_3 = 63,
	GRECO_QUEUE_ID_DCORE1_TPC_2_0 = 64,
	GRECO_QUEUE_ID_DCORE1_TPC_2_1 = 65,
	GRECO_QUEUE_ID_DCORE1_TPC_2_2 = 66,
	GRECO_QUEUE_ID_DCORE1_TPC_2_3 = 67,
	GRECO_QUEUE_ID_DCORE1_TPC_3_0 = 68,
	GRECO_QUEUE_ID_DCORE1_TPC_3_1 = 69,
	GRECO_QUEUE_ID_DCORE1_TPC_3_2 = 70,
	GRECO_QUEUE_ID_DCORE1_TPC_3_3 = 71,
	GRECO_QUEUE_ID_DCORE1_TPC_4_0 = 72,
	GRECO_QUEUE_ID_DCORE1_TPC_4_1 = 73,
	GRECO_QUEUE_ID_DCORE1_TPC_4_2 = 74,
	GRECO_QUEUE_ID_DCORE1_TPC_4_3 = 75,
	GRECO_QUEUE_ID_DCORE1_ROT_0_0 = 76,
	GRECO_QUEUE_ID_DCORE1_ROT_0_1 = 77,
	GRECO_QUEUE_ID_DCORE1_ROT_0_2 = 78,
	GRECO_QUEUE_ID_DCORE1_ROT_0_3 = 79,
	GRECO_QUEUE_ID_CPU_PQ = 80,
	GRECO_QUEUE_ID_SIZE
};

/*
 * In GAUDI2 we have two modes of operation in regard to queues:
 * 1. Legacy mode, where each QMAN exposes 4 streams to the user
 * 2. F/W mode, where we use F/W to schedule the JOBS to the different queues.
 *
 * When in legacy mode, the user sends the queue id per JOB according to
 * enum gaudi2_queue_id below.
 *
 * When in F/W mode, the user sends a stream id per Command Submission. The
 * stream id is a running number from 0 up to (N-1), where N is the number
 * of streams the F/W exposes and is passed to the user in
 * struct hl_info_hw_ip_info
 */

enum gaudi2_queue_id {
	GAUDI2_QUEUE_ID_PDMA_0_0 = 0,
	GAUDI2_QUEUE_ID_PDMA_0_1 = 1,
	GAUDI2_QUEUE_ID_PDMA_0_2 = 2,
	GAUDI2_QUEUE_ID_PDMA_0_3 = 3,
	GAUDI2_QUEUE_ID_PDMA_1_0 = 4,
	GAUDI2_QUEUE_ID_PDMA_1_1 = 5,
	GAUDI2_QUEUE_ID_PDMA_1_2 = 6,
	GAUDI2_QUEUE_ID_PDMA_1_3 = 7,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_0_0 = 8,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_0_1 = 9,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_0_2 = 10,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_0_3 = 11,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_1_0 = 12,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_1_1 = 13,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_1_2 = 14,
	GAUDI2_QUEUE_ID_DCORE0_EDMA_1_3 = 15,
	GAUDI2_QUEUE_ID_DCORE0_MME_0_0 = 16,
	GAUDI2_QUEUE_ID_DCORE0_MME_0_1 = 17,
	GAUDI2_QUEUE_ID_DCORE0_MME_0_2 = 18,
	GAUDI2_QUEUE_ID_DCORE0_MME_0_3 = 19,
	GAUDI2_QUEUE_ID_DCORE0_TPC_0_0 = 20,
	GAUDI2_QUEUE_ID_DCORE0_TPC_0_1 = 21,
	GAUDI2_QUEUE_ID_DCORE0_TPC_0_2 = 22,
	GAUDI2_QUEUE_ID_DCORE0_TPC_0_3 = 23,
	GAUDI2_QUEUE_ID_DCORE0_TPC_1_0 = 24,
	GAUDI2_QUEUE_ID_DCORE0_TPC_1_1 = 25,
	GAUDI2_QUEUE_ID_DCORE0_TPC_1_2 = 26,
	GAUDI2_QUEUE_ID_DCORE0_TPC_1_3 = 27,
	GAUDI2_QUEUE_ID_DCORE0_TPC_2_0 = 28,
	GAUDI2_QUEUE_ID_DCORE0_TPC_2_1 = 29,
	GAUDI2_QUEUE_ID_DCORE0_TPC_2_2 = 30,
	GAUDI2_QUEUE_ID_DCORE0_TPC_2_3 = 31,
	GAUDI2_QUEUE_ID_DCORE0_TPC_3_0 = 32,
	GAUDI2_QUEUE_ID_DCORE0_TPC_3_1 = 33,
	GAUDI2_QUEUE_ID_DCORE0_TPC_3_2 = 34,
	GAUDI2_QUEUE_ID_DCORE0_TPC_3_3 = 35,
	GAUDI2_QUEUE_ID_DCORE0_TPC_4_0 = 36,
	GAUDI2_QUEUE_ID_DCORE0_TPC_4_1 = 37,
	GAUDI2_QUEUE_ID_DCORE0_TPC_4_2 = 38,
	GAUDI2_QUEUE_ID_DCORE0_TPC_4_3 = 39,
	GAUDI2_QUEUE_ID_DCORE0_TPC_5_0 = 40,
	GAUDI2_QUEUE_ID_DCORE0_TPC_5_1 = 41,
	GAUDI2_QUEUE_ID_DCORE0_TPC_5_2 = 42,
	GAUDI2_QUEUE_ID_DCORE0_TPC_5_3 = 43,
	GAUDI2_QUEUE_ID_DCORE0_TPC_6_0 = 44,
	GAUDI2_QUEUE_ID_DCORE0_TPC_6_1 = 45,
	GAUDI2_QUEUE_ID_DCORE0_TPC_6_2 = 46,
	GAUDI2_QUEUE_ID_DCORE0_TPC_6_3 = 47,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_0_0 = 48,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_0_1 = 49,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_0_2 = 50,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_0_3 = 51,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_1_0 = 52,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_1_1 = 53,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_1_2 = 54,
	GAUDI2_QUEUE_ID_DCORE1_EDMA_1_3 = 55,
	GAUDI2_QUEUE_ID_DCORE1_MME_0_0 = 56,
	GAUDI2_QUEUE_ID_DCORE1_MME_0_1 = 57,
	GAUDI2_QUEUE_ID_DCORE1_MME_0_2 = 58,
	GAUDI2_QUEUE_ID_DCORE1_MME_0_3 = 59,
	GAUDI2_QUEUE_ID_DCORE1_TPC_0_0 = 60,
	GAUDI2_QUEUE_ID_DCORE1_TPC_0_1 = 61,
	GAUDI2_QUEUE_ID_DCORE1_TPC_0_2 = 62,
	GAUDI2_QUEUE_ID_DCORE1_TPC_0_3 = 63,
	GAUDI2_QUEUE_ID_DCORE1_TPC_1_0 = 64,
	GAUDI2_QUEUE_ID_DCORE1_TPC_1_1 = 65,
	GAUDI2_QUEUE_ID_DCORE1_TPC_1_2 = 66,
	GAUDI2_QUEUE_ID_DCORE1_TPC_1_3 = 67,
	GAUDI2_QUEUE_ID_DCORE1_TPC_2_0 = 68,
	GAUDI2_QUEUE_ID_DCORE1_TPC_2_1 = 69,
	GAUDI2_QUEUE_ID_DCORE1_TPC_2_2 = 70,
	GAUDI2_QUEUE_ID_DCORE1_TPC_2_3 = 71,
	GAUDI2_QUEUE_ID_DCORE1_TPC_3_0 = 72,
	GAUDI2_QUEUE_ID_DCORE1_TPC_3_1 = 73,
	GAUDI2_QUEUE_ID_DCORE1_TPC_3_2 = 74,
	GAUDI2_QUEUE_ID_DCORE1_TPC_3_3 = 75,
	GAUDI2_QUEUE_ID_DCORE1_TPC_4_0 = 76,
	GAUDI2_QUEUE_ID_DCORE1_TPC_4_1 = 77,
	GAUDI2_QUEUE_ID_DCORE1_TPC_4_2 = 78,
	GAUDI2_QUEUE_ID_DCORE1_TPC_4_3 = 79,
	GAUDI2_QUEUE_ID_DCORE1_TPC_5_0 = 80,
	GAUDI2_QUEUE_ID_DCORE1_TPC_5_1 = 81,
	GAUDI2_QUEUE_ID_DCORE1_TPC_5_2 = 82,
	GAUDI2_QUEUE_ID_DCORE1_TPC_5_3 = 83,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_0_0 = 84,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_0_1 = 85,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_0_2 = 86,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_0_3 = 87,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_1_0 = 88,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_1_1 = 89,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_1_2 = 90,
	GAUDI2_QUEUE_ID_DCORE2_EDMA_1_3 = 91,
	GAUDI2_QUEUE_ID_DCORE2_MME_0_0 = 92,
	GAUDI2_QUEUE_ID_DCORE2_MME_0_1 = 93,
	GAUDI2_QUEUE_ID_DCORE2_MME_0_2 = 94,
	GAUDI2_QUEUE_ID_DCORE2_MME_0_3 = 95,
	GAUDI2_QUEUE_ID_DCORE2_TPC_0_0 = 96,
	GAUDI2_QUEUE_ID_DCORE2_TPC_0_1 = 97,
	GAUDI2_QUEUE_ID_DCORE2_TPC_0_2 = 98,
	GAUDI2_QUEUE_ID_DCORE2_TPC_0_3 = 99,
	GAUDI2_QUEUE_ID_DCORE2_TPC_1_0 = 100,
	GAUDI2_QUEUE_ID_DCORE2_TPC_1_1 = 101,
	GAUDI2_QUEUE_ID_DCORE2_TPC_1_2 = 102,
	GAUDI2_QUEUE_ID_DCORE2_TPC_1_3 = 103,
	GAUDI2_QUEUE_ID_DCORE2_TPC_2_0 = 104,
	GAUDI2_QUEUE_ID_DCORE2_TPC_2_1 = 105,
	GAUDI2_QUEUE_ID_DCORE2_TPC_2_2 = 106,
	GAUDI2_QUEUE_ID_DCORE2_TPC_2_3 = 107,
	GAUDI2_QUEUE_ID_DCORE2_TPC_3_0 = 108,
	GAUDI2_QUEUE_ID_DCORE2_TPC_3_1 = 109,
	GAUDI2_QUEUE_ID_DCORE2_TPC_3_2 = 110,
	GAUDI2_QUEUE_ID_DCORE2_TPC_3_3 = 111,
	GAUDI2_QUEUE_ID_DCORE2_TPC_4_0 = 112,
	GAUDI2_QUEUE_ID_DCORE2_TPC_4_1 = 113,
	GAUDI2_QUEUE_ID_DCORE2_TPC_4_2 = 114,
	GAUDI2_QUEUE_ID_DCORE2_TPC_4_3 = 115,
	GAUDI2_QUEUE_ID_DCORE2_TPC_5_0 = 116,
	GAUDI2_QUEUE_ID_DCORE2_TPC_5_1 = 117,
	GAUDI2_QUEUE_ID_DCORE2_TPC_5_2 = 118,
	GAUDI2_QUEUE_ID_DCORE2_TPC_5_3 = 119,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_0_0 = 120,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_0_1 = 121,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_0_2 = 122,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_0_3 = 123,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_1_0 = 124,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_1_1 = 125,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_1_2 = 126,
	GAUDI2_QUEUE_ID_DCORE3_EDMA_1_3 = 127,
	GAUDI2_QUEUE_ID_DCORE3_MME_0_0 = 128,
	GAUDI2_QUEUE_ID_DCORE3_MME_0_1 = 129,
	GAUDI2_QUEUE_ID_DCORE3_MME_0_2 = 130,
	GAUDI2_QUEUE_ID_DCORE3_MME_0_3 = 131,
	GAUDI2_QUEUE_ID_DCORE3_TPC_0_0 = 132,
	GAUDI2_QUEUE_ID_DCORE3_TPC_0_1 = 133,
	GAUDI2_QUEUE_ID_DCORE3_TPC_0_2 = 134,
	GAUDI2_QUEUE_ID_DCORE3_TPC_0_3 = 135,
	GAUDI2_QUEUE_ID_DCORE3_TPC_1_0 = 136,
	GAUDI2_QUEUE_ID_DCORE3_TPC_1_1 = 137,
	GAUDI2_QUEUE_ID_DCORE3_TPC_1_2 = 138,
	GAUDI2_QUEUE_ID_DCORE3_TPC_1_3 = 139,
	GAUDI2_QUEUE_ID_DCORE3_TPC_2_0 = 140,
	GAUDI2_QUEUE_ID_DCORE3_TPC_2_1 = 141,
	GAUDI2_QUEUE_ID_DCORE3_TPC_2_2 = 142,
	GAUDI2_QUEUE_ID_DCORE3_TPC_2_3 = 143,
	GAUDI2_QUEUE_ID_DCORE3_TPC_3_0 = 144,
	GAUDI2_QUEUE_ID_DCORE3_TPC_3_1 = 145,
	GAUDI2_QUEUE_ID_DCORE3_TPC_3_2 = 146,
	GAUDI2_QUEUE_ID_DCORE3_TPC_3_3 = 147,
	GAUDI2_QUEUE_ID_DCORE3_TPC_4_0 = 148,
	GAUDI2_QUEUE_ID_DCORE3_TPC_4_1 = 149,
	GAUDI2_QUEUE_ID_DCORE3_TPC_4_2 = 150,
	GAUDI2_QUEUE_ID_DCORE3_TPC_4_3 = 151,
	GAUDI2_QUEUE_ID_DCORE3_TPC_5_0 = 152,
	GAUDI2_QUEUE_ID_DCORE3_TPC_5_1 = 153,
	GAUDI2_QUEUE_ID_DCORE3_TPC_5_2 = 154,
	GAUDI2_QUEUE_ID_DCORE3_TPC_5_3 = 155,
	GAUDI2_QUEUE_ID_NIC_0_0 = 156,
	GAUDI2_QUEUE_ID_NIC_0_1 = 157,
	GAUDI2_QUEUE_ID_NIC_0_2 = 158,
	GAUDI2_QUEUE_ID_NIC_0_3 = 159,
	GAUDI2_QUEUE_ID_NIC_1_0 = 160,
	GAUDI2_QUEUE_ID_NIC_1_1 = 161,
	GAUDI2_QUEUE_ID_NIC_1_2 = 162,
	GAUDI2_QUEUE_ID_NIC_1_3 = 163,
	GAUDI2_QUEUE_ID_NIC_2_0 = 164,
	GAUDI2_QUEUE_ID_NIC_2_1 = 165,
	GAUDI2_QUEUE_ID_NIC_2_2 = 166,
	GAUDI2_QUEUE_ID_NIC_2_3 = 167,
	GAUDI2_QUEUE_ID_NIC_3_0 = 168,
	GAUDI2_QUEUE_ID_NIC_3_1 = 169,
	GAUDI2_QUEUE_ID_NIC_3_2 = 170,
	GAUDI2_QUEUE_ID_NIC_3_3 = 171,
	GAUDI2_QUEUE_ID_NIC_4_0 = 172,
	GAUDI2_QUEUE_ID_NIC_4_1 = 173,
	GAUDI2_QUEUE_ID_NIC_4_2 = 174,
	GAUDI2_QUEUE_ID_NIC_4_3 = 175,
	GAUDI2_QUEUE_ID_NIC_5_0 = 176,
	GAUDI2_QUEUE_ID_NIC_5_1 = 177,
	GAUDI2_QUEUE_ID_NIC_5_2 = 178,
	GAUDI2_QUEUE_ID_NIC_5_3 = 179,
	GAUDI2_QUEUE_ID_NIC_6_0 = 180,
	GAUDI2_QUEUE_ID_NIC_6_1 = 181,
	GAUDI2_QUEUE_ID_NIC_6_2 = 182,
	GAUDI2_QUEUE_ID_NIC_6_3 = 183,
	GAUDI2_QUEUE_ID_NIC_7_0 = 184,
	GAUDI2_QUEUE_ID_NIC_7_1 = 185,
	GAUDI2_QUEUE_ID_NIC_7_2 = 186,
	GAUDI2_QUEUE_ID_NIC_7_3 = 187,
	GAUDI2_QUEUE_ID_NIC_8_0 = 188,
	GAUDI2_QUEUE_ID_NIC_8_1 = 189,
	GAUDI2_QUEUE_ID_NIC_8_2 = 190,
	GAUDI2_QUEUE_ID_NIC_8_3 = 191,
	GAUDI2_QUEUE_ID_NIC_9_0 = 192,
	GAUDI2_QUEUE_ID_NIC_9_1 = 193,
	GAUDI2_QUEUE_ID_NIC_9_2 = 194,
	GAUDI2_QUEUE_ID_NIC_9_3 = 195,
	GAUDI2_QUEUE_ID_NIC_10_0 = 196,
	GAUDI2_QUEUE_ID_NIC_10_1 = 197,
	GAUDI2_QUEUE_ID_NIC_10_2 = 198,
	GAUDI2_QUEUE_ID_NIC_10_3 = 199,
	GAUDI2_QUEUE_ID_NIC_11_0 = 200,
	GAUDI2_QUEUE_ID_NIC_11_1 = 201,
	GAUDI2_QUEUE_ID_NIC_11_2 = 202,
	GAUDI2_QUEUE_ID_NIC_11_3 = 203,
	GAUDI2_QUEUE_ID_NIC_12_0 = 204,
	GAUDI2_QUEUE_ID_NIC_12_1 = 205,
	GAUDI2_QUEUE_ID_NIC_12_2 = 206,
	GAUDI2_QUEUE_ID_NIC_12_3 = 207,
	GAUDI2_QUEUE_ID_NIC_13_0 = 208,
	GAUDI2_QUEUE_ID_NIC_13_1 = 209,
	GAUDI2_QUEUE_ID_NIC_13_2 = 210,
	GAUDI2_QUEUE_ID_NIC_13_3 = 211,
	GAUDI2_QUEUE_ID_NIC_14_0 = 212,
	GAUDI2_QUEUE_ID_NIC_14_1 = 213,
	GAUDI2_QUEUE_ID_NIC_14_2 = 214,
	GAUDI2_QUEUE_ID_NIC_14_3 = 215,
	GAUDI2_QUEUE_ID_NIC_15_0 = 216,
	GAUDI2_QUEUE_ID_NIC_15_1 = 217,
	GAUDI2_QUEUE_ID_NIC_15_2 = 218,
	GAUDI2_QUEUE_ID_NIC_15_3 = 219,
	GAUDI2_QUEUE_ID_NIC_16_0 = 220,
	GAUDI2_QUEUE_ID_NIC_16_1 = 221,
	GAUDI2_QUEUE_ID_NIC_16_2 = 222,
	GAUDI2_QUEUE_ID_NIC_16_3 = 223,
	GAUDI2_QUEUE_ID_NIC_17_0 = 224,
	GAUDI2_QUEUE_ID_NIC_17_1 = 225,
	GAUDI2_QUEUE_ID_NIC_17_2 = 226,
	GAUDI2_QUEUE_ID_NIC_17_3 = 227,
	GAUDI2_QUEUE_ID_NIC_18_0 = 228,
	GAUDI2_QUEUE_ID_NIC_18_1 = 229,
	GAUDI2_QUEUE_ID_NIC_18_2 = 230,
	GAUDI2_QUEUE_ID_NIC_18_3 = 231,
	GAUDI2_QUEUE_ID_NIC_19_0 = 232,
	GAUDI2_QUEUE_ID_NIC_19_1 = 233,
	GAUDI2_QUEUE_ID_NIC_19_2 = 234,
	GAUDI2_QUEUE_ID_NIC_19_3 = 235,
	GAUDI2_QUEUE_ID_NIC_20_0 = 236,
	GAUDI2_QUEUE_ID_NIC_20_1 = 237,
	GAUDI2_QUEUE_ID_NIC_20_2 = 238,
	GAUDI2_QUEUE_ID_NIC_20_3 = 239,
	GAUDI2_QUEUE_ID_NIC_21_0 = 240,
	GAUDI2_QUEUE_ID_NIC_21_1 = 241,
	GAUDI2_QUEUE_ID_NIC_21_2 = 242,
	GAUDI2_QUEUE_ID_NIC_21_3 = 243,
	GAUDI2_QUEUE_ID_NIC_22_0 = 244,
	GAUDI2_QUEUE_ID_NIC_22_1 = 245,
	GAUDI2_QUEUE_ID_NIC_22_2 = 246,
	GAUDI2_QUEUE_ID_NIC_22_3 = 247,
	GAUDI2_QUEUE_ID_NIC_23_0 = 248,
	GAUDI2_QUEUE_ID_NIC_23_1 = 249,
	GAUDI2_QUEUE_ID_NIC_23_2 = 250,
	GAUDI2_QUEUE_ID_NIC_23_3 = 251,
	GAUDI2_QUEUE_ID_ROT_0_0 = 252,
	GAUDI2_QUEUE_ID_ROT_0_1 = 253,
	GAUDI2_QUEUE_ID_ROT_0_2 = 254,
	GAUDI2_QUEUE_ID_ROT_0_3 = 255,
	GAUDI2_QUEUE_ID_ROT_1_0 = 256,
	GAUDI2_QUEUE_ID_ROT_1_1 = 257,
	GAUDI2_QUEUE_ID_ROT_1_2 = 258,
	GAUDI2_QUEUE_ID_ROT_1_3 = 259,
	GAUDI2_QUEUE_ID_CPU_PQ = 260,
	GAUDI2_QUEUE_ID_SIZE
};

/*
 * Engine Numbering
 *
 * Used in the "busy_engines_mask" field in `struct hl_info_hw_idle'
 */

enum goya_engine_id {
	GOYA_ENGINE_ID_DMA_0 = 0,
	GOYA_ENGINE_ID_DMA_1,
	GOYA_ENGINE_ID_DMA_2,
	GOYA_ENGINE_ID_DMA_3,
	GOYA_ENGINE_ID_DMA_4,
	GOYA_ENGINE_ID_MME_0,
	GOYA_ENGINE_ID_TPC_0,
	GOYA_ENGINE_ID_TPC_1,
	GOYA_ENGINE_ID_TPC_2,
	GOYA_ENGINE_ID_TPC_3,
	GOYA_ENGINE_ID_TPC_4,
	GOYA_ENGINE_ID_TPC_5,
	GOYA_ENGINE_ID_TPC_6,
	GOYA_ENGINE_ID_TPC_7,
	GOYA_ENGINE_ID_SIZE
};

enum gaudi_engine_id {
	GAUDI_ENGINE_ID_DMA_0 = 0,
	GAUDI_ENGINE_ID_DMA_1,
	GAUDI_ENGINE_ID_DMA_2,
	GAUDI_ENGINE_ID_DMA_3,
	GAUDI_ENGINE_ID_DMA_4,
	GAUDI_ENGINE_ID_DMA_5,
	GAUDI_ENGINE_ID_DMA_6,
	GAUDI_ENGINE_ID_DMA_7,
	GAUDI_ENGINE_ID_MME_0,
	GAUDI_ENGINE_ID_MME_1,
	GAUDI_ENGINE_ID_MME_2,
	GAUDI_ENGINE_ID_MME_3,
	GAUDI_ENGINE_ID_TPC_0,
	GAUDI_ENGINE_ID_TPC_1,
	GAUDI_ENGINE_ID_TPC_2,
	GAUDI_ENGINE_ID_TPC_3,
	GAUDI_ENGINE_ID_TPC_4,
	GAUDI_ENGINE_ID_TPC_5,
	GAUDI_ENGINE_ID_TPC_6,
	GAUDI_ENGINE_ID_TPC_7,
	GAUDI_ENGINE_ID_NIC_0,
	GAUDI_ENGINE_ID_NIC_1,
	GAUDI_ENGINE_ID_NIC_2,
	GAUDI_ENGINE_ID_NIC_3,
	GAUDI_ENGINE_ID_NIC_4,
	GAUDI_ENGINE_ID_NIC_5,
	GAUDI_ENGINE_ID_NIC_6,
	GAUDI_ENGINE_ID_NIC_7,
	GAUDI_ENGINE_ID_NIC_8,
	GAUDI_ENGINE_ID_NIC_9,
	GAUDI_ENGINE_ID_SIZE
};

enum greco_engine_id {
	GRECO_DCORE0_ENGINE_ID_DDMA = 0,
	GRECO_DCORE0_ENGINE_ID_PDMA_0,
	GRECO_DCORE0_ENGINE_ID_PDMA_1,
	GRECO_DCORE0_ENGINE_ID_MME,
	GRECO_DCORE0_ENGINE_ID_TPC_0,
	GRECO_DCORE0_ENGINE_ID_TPC_1,
	GRECO_DCORE0_ENGINE_ID_TPC_2,
	GRECO_DCORE0_ENGINE_ID_TPC_3,
	GRECO_DCORE0_ENGINE_ID_TPC_4,
	GRECO_DCORE0_ENGINE_ID_DEC_0,
	GRECO_DCORE0_ENGINE_ID_DEC_1,
	GRECO_DCORE0_ENGINE_ID_DEC_2,
	GRECO_DCORE0_ENGINE_ID_DEC_3,
	GRECO_DCORE0_ENGINE_ID_DEC_4,
	GRECO_DCORE0_ENGINE_ID_ROT,
	GRECO_DCORE1_ENGINE_ID_DDMA,
	GRECO_DCORE1_ENGINE_ID_PDMA_0,
	GRECO_DCORE1_ENGINE_ID_PDMA_1,
	GRECO_DCORE1_ENGINE_ID_MME,
	GRECO_DCORE1_ENGINE_ID_TPC_0,
	GRECO_DCORE1_ENGINE_ID_TPC_1,
	GRECO_DCORE1_ENGINE_ID_TPC_2,
	GRECO_DCORE1_ENGINE_ID_TPC_3,
	GRECO_DCORE1_ENGINE_ID_TPC_4,
	GRECO_DCORE1_ENGINE_ID_DEC_0,
	GRECO_DCORE1_ENGINE_ID_DEC_1,
	GRECO_DCORE1_ENGINE_ID_DEC_2,
	GRECO_DCORE1_ENGINE_ID_DEC_3,
	GRECO_DCORE1_ENGINE_ID_DEC_4,
	GRECO_DCORE1_ENGINE_ID_ROT,
	GRECO_ENGINE_ID_ENC,
	GRECO_ENGINE_ID_SIZE
};

enum gaudi2_engine_id {
	GAUDI2_DCORE0_ENGINE_ID_EDMA_0 = 0,
	GAUDI2_DCORE0_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE0_ENGINE_ID_MME,
	GAUDI2_DCORE0_ENGINE_ID_TPC_0,
	GAUDI2_DCORE0_ENGINE_ID_TPC_1,
	GAUDI2_DCORE0_ENGINE_ID_TPC_2,
	GAUDI2_DCORE0_ENGINE_ID_TPC_3,
	GAUDI2_DCORE0_ENGINE_ID_TPC_4,
	GAUDI2_DCORE0_ENGINE_ID_TPC_5,
	GAUDI2_DCORE0_ENGINE_ID_DEC_0,
	GAUDI2_DCORE0_ENGINE_ID_DEC_1,
	GAUDI2_DCORE1_ENGINE_ID_EDMA_0,
	GAUDI2_DCORE1_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE1_ENGINE_ID_MME,
	GAUDI2_DCORE1_ENGINE_ID_TPC_0,
	GAUDI2_DCORE1_ENGINE_ID_TPC_1,
	GAUDI2_DCORE1_ENGINE_ID_TPC_2,
	GAUDI2_DCORE1_ENGINE_ID_TPC_3,
	GAUDI2_DCORE1_ENGINE_ID_TPC_4,
	GAUDI2_DCORE1_ENGINE_ID_TPC_5,
	GAUDI2_DCORE1_ENGINE_ID_DEC_0,
	GAUDI2_DCORE1_ENGINE_ID_DEC_1,
	GAUDI2_DCORE2_ENGINE_ID_EDMA_0,
	GAUDI2_DCORE2_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE2_ENGINE_ID_MME,
	GAUDI2_DCORE2_ENGINE_ID_TPC_0,
	GAUDI2_DCORE2_ENGINE_ID_TPC_1,
	GAUDI2_DCORE2_ENGINE_ID_TPC_2,
	GAUDI2_DCORE2_ENGINE_ID_TPC_3,
	GAUDI2_DCORE2_ENGINE_ID_TPC_4,
	GAUDI2_DCORE2_ENGINE_ID_TPC_5,
	GAUDI2_DCORE2_ENGINE_ID_DEC_0,
	GAUDI2_DCORE2_ENGINE_ID_DEC_1,
	GAUDI2_DCORE3_ENGINE_ID_EDMA_0,
	GAUDI2_DCORE3_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE3_ENGINE_ID_MME,
	GAUDI2_DCORE3_ENGINE_ID_TPC_0,
	GAUDI2_DCORE3_ENGINE_ID_TPC_1,
	GAUDI2_DCORE3_ENGINE_ID_TPC_2,
	GAUDI2_DCORE3_ENGINE_ID_TPC_3,
	GAUDI2_DCORE3_ENGINE_ID_TPC_4,
	GAUDI2_DCORE3_ENGINE_ID_TPC_5,
	GAUDI2_DCORE3_ENGINE_ID_DEC_0,
	GAUDI2_DCORE3_ENGINE_ID_DEC_1,
	GAUDI2_DCORE0_ENGINE_ID_TPC_6,
	GAUDI2_ENGINE_ID_PDMA_0,
	GAUDI2_ENGINE_ID_PDMA_1,
	GAUDI2_ENGINE_ID_ROT_0,
	GAUDI2_ENGINE_ID_ROT_1,
	GAUDI2_PCIE_ENGINE_ID_DEC_0,
	GAUDI2_PCIE_ENGINE_ID_DEC_1,
	GAUDI2_ENGINE_ID_NIC0_0,
	GAUDI2_ENGINE_ID_NIC0_1,
	GAUDI2_ENGINE_ID_NIC1_0,
	GAUDI2_ENGINE_ID_NIC1_1,
	GAUDI2_ENGINE_ID_NIC2_0,
	GAUDI2_ENGINE_ID_NIC2_1,
	GAUDI2_ENGINE_ID_NIC3_0,
	GAUDI2_ENGINE_ID_NIC3_1,
	GAUDI2_ENGINE_ID_NIC4_0,
	GAUDI2_ENGINE_ID_NIC4_1,
	GAUDI2_ENGINE_ID_NIC5_0,
	GAUDI2_ENGINE_ID_NIC5_1,
	GAUDI2_ENGINE_ID_NIC6_0,
	GAUDI2_ENGINE_ID_NIC6_1,
	GAUDI2_ENGINE_ID_NIC7_0,
	GAUDI2_ENGINE_ID_NIC7_1,
	GAUDI2_ENGINE_ID_NIC8_0,
	GAUDI2_ENGINE_ID_NIC8_1,
	GAUDI2_ENGINE_ID_NIC9_0,
	GAUDI2_ENGINE_ID_NIC9_1,
	GAUDI2_ENGINE_ID_NIC10_0,
	GAUDI2_ENGINE_ID_NIC10_1,
	GAUDI2_ENGINE_ID_NIC11_0,
	GAUDI2_ENGINE_ID_NIC11_1,
	GAUDI2_ENGINE_ID_PCIE,
	GAUDI2_ENGINE_ID_PSOC,
	GAUDI2_ENGINE_ID_ARC_FARM,
	GAUDI2_ENGINE_ID_KDMA,
	GAUDI2_ENGINE_ID_SIZE
};

enum gaudi3_engine_id {
	GAUDI3_HDCORE0_ENGINE_ID_DEC_0 = 0,
	GAUDI3_HDCORE0_ENGINE_ID_DEC_1 = 1,
	GAUDI3_HDCORE1_ENGINE_ID_DEC_0 = 2,
	GAUDI3_HDCORE1_ENGINE_ID_DEC_1 = 3,
	GAUDI3_HDCORE2_ENGINE_ID_DEC_0 = 4,
	GAUDI3_HDCORE2_ENGINE_ID_DEC_1 = 5,
	GAUDI3_HDCORE3_ENGINE_ID_DEC_0 = 6,
	GAUDI3_HDCORE3_ENGINE_ID_DEC_1 = 7,
	GAUDI3_HDCORE4_ENGINE_ID_DEC_0 = 8,
	GAUDI3_HDCORE4_ENGINE_ID_DEC_1 = 9,
	GAUDI3_HDCORE5_ENGINE_ID_DEC_0 = 10,
	GAUDI3_HDCORE5_ENGINE_ID_DEC_1 = 11,
	GAUDI3_HDCORE6_ENGINE_ID_DEC_0 = 12,
	GAUDI3_HDCORE6_ENGINE_ID_DEC_1 = 13,
	GAUDI3_HDCORE7_ENGINE_ID_DEC_0 = 14,
	GAUDI3_HDCORE7_ENGINE_ID_DEC_1 = 15,
	GAUDI3_HDCORE1_ENGINE_ID_EDMA_0 = 16,
	GAUDI3_HDCORE1_ENGINE_ID_EDMA_1 = 17,
	GAUDI3_HDCORE3_ENGINE_ID_EDMA_0 = 18,
	GAUDI3_HDCORE3_ENGINE_ID_EDMA_1 = 19,
	GAUDI3_HDCORE4_ENGINE_ID_EDMA_0 = 20,
	GAUDI3_HDCORE4_ENGINE_ID_EDMA_1 = 21,
	GAUDI3_HDCORE6_ENGINE_ID_EDMA_0 = 22,
	GAUDI3_HDCORE6_ENGINE_ID_EDMA_1 = 23,
	GAUDI3_HDCORE0_ENGINE_ID_MME_0 = 24,
	GAUDI3_HDCORE1_ENGINE_ID_MME_0 = 25,
	GAUDI3_HDCORE2_ENGINE_ID_MME_0 = 26,
	GAUDI3_HDCORE3_ENGINE_ID_MME_0 = 27,
	GAUDI3_HDCORE4_ENGINE_ID_MME_0 = 28,
	GAUDI3_HDCORE5_ENGINE_ID_MME_0 = 29,
	GAUDI3_HDCORE6_ENGINE_ID_MME_0 = 30,
	GAUDI3_HDCORE7_ENGINE_ID_MME_0 = 31,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_0 = 32,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_1 = 33,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_2 = 34,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_3 = 35,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_4 = 36,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_5 = 37,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_6 = 38,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_7 = 39,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_0 = 40,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_1 = 41,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_2 = 42,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_3 = 43,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_4 = 44,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_5 = 45,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_6 = 46,
	GAUDI3_HDCORE1_ENGINE_ID_TPC_7 = 47,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_0 = 48,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_1 = 49,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_2 = 50,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_3 = 51,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_4 = 52,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_5 = 53,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_6 = 54,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_7 = 55,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_0 = 56,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_1 = 57,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_2 = 58,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_3 = 59,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_4 = 60,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_5 = 61,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_6 = 62,
	GAUDI3_HDCORE3_ENGINE_ID_TPC_7 = 63,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_0 = 64,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_1 = 65,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_2 = 66,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_3 = 67,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_4 = 68,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_5 = 69,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_6 = 70,
	GAUDI3_HDCORE4_ENGINE_ID_TPC_7 = 71,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_0 = 72,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_1 = 73,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_2 = 74,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_3 = 75,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_4 = 76,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_5 = 77,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_6 = 78,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_7 = 79,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_0 = 80,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_1 = 81,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_2 = 82,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_3 = 83,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_4 = 84,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_5 = 85,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_6 = 86,
	GAUDI3_HDCORE6_ENGINE_ID_TPC_7 = 87,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_0 = 88,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_1 = 89,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_2 = 90,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_3 = 91,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_4 = 92,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_5 = 93,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_6 = 94,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_7 = 95,
	GAUDI3_HDCORE0_ENGINE_ID_TPC_8 = 96,
	GAUDI3_HDCORE2_ENGINE_ID_TPC_8 = 97,
	GAUDI3_HDCORE5_ENGINE_ID_TPC_8 = 98,
	GAUDI3_HDCORE7_ENGINE_ID_TPC_8 = 99,
	GAUDI3_DIE0_ENGINE_ID_NIC_0 = 100,
	GAUDI3_DIE0_ENGINE_ID_NIC_1 = 101,
	GAUDI3_DIE0_ENGINE_ID_NIC_2 = 102,
	GAUDI3_DIE0_ENGINE_ID_NIC_3 = 103,
	GAUDI3_DIE0_ENGINE_ID_NIC_4 = 104,
	GAUDI3_DIE0_ENGINE_ID_NIC_5 = 105,
	GAUDI3_DIE1_ENGINE_ID_NIC_0 = 106,
	GAUDI3_DIE1_ENGINE_ID_NIC_1 = 107,
	GAUDI3_DIE1_ENGINE_ID_NIC_2 = 108,
	GAUDI3_DIE1_ENGINE_ID_NIC_3 = 109,
	GAUDI3_DIE1_ENGINE_ID_NIC_4 = 110,
	GAUDI3_DIE1_ENGINE_ID_NIC_5 = 111,
	GAUDI3_HDCORE1_ENGINE_ID_ROT_0 = 112,
	GAUDI3_HDCORE1_ENGINE_ID_ROT_1 = 113,
	GAUDI3_HDCORE3_ENGINE_ID_ROT_0 = 114,
	GAUDI3_HDCORE3_ENGINE_ID_ROT_1 = 115,
	GAUDI3_HDCORE4_ENGINE_ID_ROT_0 = 116,
	GAUDI3_HDCORE4_ENGINE_ID_ROT_1 = 117,
	GAUDI3_HDCORE6_ENGINE_ID_ROT_0 = 118,
	GAUDI3_HDCORE6_ENGINE_ID_ROT_1 = 119,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_CH_0 = 120,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_CH_1 = 121,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_CH_2 = 122,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_CH_3 = 123,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_CH_4 = 124,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_CH_5 = 125,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_CH_0 = 126,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_CH_1 = 127,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_CH_2 = 128,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_CH_3 = 129,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_CH_4 = 130,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_CH_5 = 131,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_CH_0 = 132,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_CH_1 = 133,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_CH_2 = 134,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_CH_3 = 135,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_CH_4 = 136,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_CH_5 = 137,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_CH_0 = 138,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_CH_1 = 139,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_CH_2 = 140,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_CH_3 = 141,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_CH_4 = 142,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_CH_5 = 143,
	GAUDI3_HDCORE0_ENGINE_ID_STLB = 144,
	GAUDI3_HDCORE1_ENGINE_ID_STLB = 145,
	GAUDI3_HDCORE2_ENGINE_ID_STLB = 146,
	GAUDI3_HDCORE3_ENGINE_ID_STLB = 147,
	GAUDI3_HDCORE4_ENGINE_ID_STLB = 148,
	GAUDI3_HDCORE5_ENGINE_ID_STLB = 149,
	GAUDI3_HDCORE6_ENGINE_ID_STLB = 150,
	GAUDI3_HDCORE7_ENGINE_ID_STLB = 151,
	GAUDI3_HDCORE0_ENGINE_ID_SM = 152,
	GAUDI3_HDCORE1_ENGINE_ID_SM = 153,
	GAUDI3_HDCORE2_ENGINE_ID_SM = 154,
	GAUDI3_HDCORE3_ENGINE_ID_SM = 155,
	GAUDI3_HDCORE4_ENGINE_ID_SM = 156,
	GAUDI3_HDCORE5_ENGINE_ID_SM = 157,
	GAUDI3_HDCORE6_ENGINE_ID_SM = 158,
	GAUDI3_HDCORE7_ENGINE_ID_SM = 159,
	GAUDI3_HDCORE0_ENGINE_ID_ARCF_0 = 160,
	GAUDI3_HDCORE0_ENGINE_ID_ARCF_1 = 161,
	GAUDI3_HDCORE1_ENGINE_ID_ARCF_0 = 162,
	GAUDI3_HDCORE1_ENGINE_ID_ARCF_1 = 163,
	GAUDI3_HDCORE2_ENGINE_ID_ARCF_0 = 164,
	GAUDI3_HDCORE2_ENGINE_ID_ARCF_1 = 165,
	GAUDI3_HDCORE3_ENGINE_ID_ARCF_0 = 166,
	GAUDI3_HDCORE3_ENGINE_ID_ARCF_1 = 167,
	GAUDI3_HDCORE4_ENGINE_ID_ARCF_0 = 168,
	GAUDI3_HDCORE4_ENGINE_ID_ARCF_1 = 169,
	GAUDI3_HDCORE5_ENGINE_ID_ARCF_0 = 170,
	GAUDI3_HDCORE5_ENGINE_ID_ARCF_1 = 171,
	GAUDI3_HDCORE6_ENGINE_ID_ARCF_0 = 172,
	GAUDI3_HDCORE6_ENGINE_ID_ARCF_1 = 173,
	GAUDI3_HDCORE7_ENGINE_ID_ARCF_0 = 174,
	GAUDI3_HDCORE7_ENGINE_ID_ARCF_1 = 175,
	GAUDI3_DIE0_ENGINE_ID_PCIE = 176,
	GAUDI3_DIE1_ENGINE_ID_PCIE = 177,
	GAUDI3_DIE0_ENGINE_ID_ETR_PSOC = 178,
	GAUDI3_DIE1_ENGINE_ID_ETR_PSOC = 179,
	GAUDI3_DIE0_ENGINE_ID_ETR_NIC = 180,
	GAUDI3_DIE1_ENGINE_ID_ETR_NIC = 181,
	GAUDI3_DIE0_ENGINE_ID_PDMA_0_DUP = 182,
	GAUDI3_DIE0_ENGINE_ID_PDMA_1_DUP = 183,
	GAUDI3_DIE1_ENGINE_ID_PDMA_0_DUP = 184,
	GAUDI3_DIE1_ENGINE_ID_PDMA_1_DUP = 185,
	GAUDI3_HDCORE0_ENGINE_ID_EDUP = 186,
	GAUDI3_HDCORE1_ENGINE_ID_EDUP = 187,
	GAUDI3_HDCORE2_ENGINE_ID_EDUP = 188,
	GAUDI3_HDCORE3_ENGINE_ID_EDUP = 189,
	GAUDI3_HDCORE4_ENGINE_ID_EDUP = 190,
	GAUDI3_HDCORE5_ENGINE_ID_EDUP = 191,
	GAUDI3_HDCORE6_ENGINE_ID_EDUP = 192,
	GAUDI3_HDCORE7_ENGINE_ID_EDUP = 193,
	GAUDI3_ENGINE_ID_SIZE,
};

/*
 * ASIC specific PLL index
 *
 * Used to retrieve in frequency info of different IPs via HL_INFO_PLL_FREQUENCY under
 * DRM_IOCTL_HL_INFO IOCTL.
 * The enums need to be used as an index in struct hl_pll_frequency_info.
 */

enum hl_goya_pll_index {
	HL_GOYA_CPU_PLL = 0,
	HL_GOYA_IC_PLL,
	HL_GOYA_MC_PLL,
	HL_GOYA_MME_PLL,
	HL_GOYA_PCI_PLL,
	HL_GOYA_EMMC_PLL,
	HL_GOYA_TPC_PLL,
	HL_GOYA_PLL_MAX
};

enum hl_gaudi_pll_index {
	HL_GAUDI_CPU_PLL = 0,
	HL_GAUDI_PCI_PLL,
	HL_GAUDI_SRAM_PLL,
	HL_GAUDI_HBM_PLL,
	HL_GAUDI_NIC_PLL,
	HL_GAUDI_DMA_PLL,
	HL_GAUDI_MESH_PLL,
	HL_GAUDI_MME_PLL,
	HL_GAUDI_TPC_PLL,
	HL_GAUDI_IF_PLL,
	HL_GAUDI_PLL_MAX
};

enum hl_greco_pll_index {
	HL_GRECO_PCI_PLL = 0,
	HL_GRECO_SIF_PLL,
	HL_GRECO_MESH_PLL,
	HL_GRECO_DDR0_PLL,
	HL_GRECO_DDR1_PLL,
	HL_GRECO_MME_PLL,
	HL_GRECO_TPC_PLL,
	HL_GRECO_VID_PLL,
	HL_GRECO_SRAM_PLL,
	HL_GRECO_MMU_PLL,
	HL_GRECO_PLL_MAX
};

enum hl_gaudi2_pll_index {
	HL_GAUDI2_CPU_PLL = 0,
	HL_GAUDI2_PCI_PLL,
	HL_GAUDI2_SRAM_PLL,
	HL_GAUDI2_HBM_PLL,
	HL_GAUDI2_NIC_PLL,
	HL_GAUDI2_DMA_PLL,
	HL_GAUDI2_MESH_PLL,
	HL_GAUDI2_MME_PLL,
	HL_GAUDI2_TPC_PLL,
	HL_GAUDI2_IF_PLL,
	HL_GAUDI2_VID_PLL,
	HL_GAUDI2_MSS_PLL,
	HL_GAUDI2_PLL_MAX
};

enum hl_gaudi3_pll_index {
	HL_GAUDI3_CPU_PLL = 0,
	HL_GAUDI3_PCI_PLL,
	HL_GAUDI3_HBM_PLL,
	HL_GAUDI3_NIC_PLL,
	HL_GAUDI3_DMA_PLL,
	HL_GAUDI3_MESH_PLL,
	HL_GAUDI3_MME_PLL,
	HL_GAUDI3_TPC_PLL,
	HL_GAUDI3_VID_PLL,
	HL_GAUDI3_D2D_PLL,
	HL_GAUDI3_CS_PLL,
	HL_GAUDI3_C2C_PLL,
	HL_GAUDI3_NCH_PLL,
	HL_GAUDI3_C2M_PLL,
	HL_GAUDI3_PLL_MAX
};

enum gaudi3_etrs {
	GAUDI3_D0_PSOC_ETR,
	GAUDI3_D0_NCH_ETR,
	GAUDI3_D1_PSOC_ETR,
	GAUDI3_D1_NCH_ETR,
	GAUDI3_NUM_ETR,
};

/**
 * enum hl_goya_dma_direction - Direction of DMA operation inside a LIN_DMA packet that is
 *                              submitted to the GOYA's DMA QMAN. This attribute is not relevant
 *                              to the H/W but the kernel driver use it to parse the packet's
 *                              addresses and patch/validate them.
 * @HL_DMA_HOST_TO_DRAM: DMA operation from Host memory to GOYA's DDR.
 * @HL_DMA_HOST_TO_SRAM: DMA operation from Host memory to GOYA's SRAM.
 * @HL_DMA_DRAM_TO_SRAM: DMA operation from GOYA's DDR to GOYA's SRAM.
 * @HL_DMA_SRAM_TO_DRAM: DMA operation from GOYA's SRAM to GOYA's DDR.
 * @HL_DMA_SRAM_TO_HOST: DMA operation from GOYA's SRAM to Host memory.
 * @HL_DMA_DRAM_TO_HOST: DMA operation from GOYA's DDR to Host memory.
 * @HL_DMA_DRAM_TO_DRAM: DMA operation from GOYA's DDR to GOYA's DDR.
 * @HL_DMA_SRAM_TO_SRAM: DMA operation from GOYA's SRAM to GOYA's SRAM.
 * @HL_DMA_ENUM_MAX: number of values in enum
 */
enum hl_goya_dma_direction {
	HL_DMA_HOST_TO_DRAM,
	HL_DMA_HOST_TO_SRAM,
	HL_DMA_DRAM_TO_SRAM,
	HL_DMA_SRAM_TO_DRAM,
	HL_DMA_SRAM_TO_HOST,
	HL_DMA_DRAM_TO_HOST,
	HL_DMA_DRAM_TO_DRAM,
	HL_DMA_SRAM_TO_SRAM,
	HL_DMA_ENUM_MAX
};

/**
 * enum hl_device_status - Device status information.
 * @HL_DEVICE_STATUS_OPERATIONAL: Device is operational.
 * @HL_DEVICE_STATUS_IN_RESET: Device is currently during reset.
 * @HL_DEVICE_STATUS_MALFUNCTION: Device is unusable.
 * @HL_DEVICE_STATUS_NEEDS_RESET: Device needs reset because auto reset was disabled.
 * @HL_DEVICE_STATUS_IN_DEVICE_CREATION: Device is operational but its creation is still in
 *                                       progress.
 * @HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE: Device is currently during reset that was
 *                                                  triggered because the user released the device
 * @HL_DEVICE_STATUS_LAST: Last status.
 */
enum hl_device_status {
	HL_DEVICE_STATUS_OPERATIONAL,
	HL_DEVICE_STATUS_IN_RESET,
	HL_DEVICE_STATUS_MALFUNCTION,
	HL_DEVICE_STATUS_NEEDS_RESET,
	HL_DEVICE_STATUS_IN_DEVICE_CREATION,
	HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE,
	HL_DEVICE_STATUS_LAST = HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE
};

/**
 * enum hl_server_type - The server configuration that the device is part of.
 * @HL_SERVER_TYPE_UNKNOWN: Unknown server configuration.
 * @HL_SERVER_GAUDI_HLS1: HLS1, 8 OAMs, all ports are enabled
 *                        7 internal
 *                        3 external
 * @HL_SERVER_GAUDI_HLS1H: 4 OAMs, all ports are enabled, all external
 * @HL_SERVER_GAUDI_TYPE1: 7 ports enabled, all internal
 * @HL_SERVER_GAUDI_TYPE2: 10 ports enabled
 *                         7 internal
 *                         3 external
 * @HL_SERVER_GAUDI2_HLS2: HLS2, 8 OAMs, all ports are enabled
 *                         21 internal
 *                         3 external
 * @HL_SERVER_GAUDI3_HLS3_DEPRECATED: Generic HLS3 configuration, deprecated.
 * @HL_SERVER_GAUDI2_TYPE1: HLS2, 8 OAMs, 21 ports are enabled, all internal.
 * @HL_SERVER_GAUDI3_HLS3_FULLSCALE_IN: HLS3, all ports are enabled and connected internally.
 * @HL_SERVER_GAUDI3_HLS3_FULLSCALE_OUT: HLS3, all ports are enabled
 *                                       14 internal (2 per card)
 *                                       10 external
 * @HL_SERVER_GAUDI3_HLS3_FULL_OAM_3PORTS_SCALE_OUT: HLS3, all ports are enabled
 *                                                   21 internal
 *                                                   3 external
 * @HL_SERVER_GAUDI3_HLS3_FULL_OAM_6PORTS_SCALE_OUT: HLS3, all ports are enabled
 *                                                   18 internal
 *                                                   6 external
 * @HL_SERVER_GAUDI3_HLS3_SINGLEPORT_OAM_FULLSCALE_OUT: HLS3, 10 ports are enabled
 *                                                      7 internal
 *                                                      3 external
 * @HL_SERVER_GAUDI3_HL338: HL338, 4 OAMs, 22 ports are enabled
 *                          18 internal (6 per card)
 *                          4 external
 */
enum hl_server_type {
	HL_SERVER_TYPE_UNKNOWN = 0,
	HL_SERVER_GAUDI_HLS1 = 1,
	HL_SERVER_GAUDI_HLS1H = 2,
	HL_SERVER_GAUDI_TYPE1 = 3,
	HL_SERVER_GAUDI_TYPE2 = 4,
	HL_SERVER_GAUDI2_HLS2 = 5,
	HL_SERVER_GAUDI3_HLS3_DEPRECATED = 6,
	HL_SERVER_GAUDI2_TYPE1 = 7,
	HL_SERVER_GAUDI3_HLS3_FULLSCALE_IN = 8,
	HL_SERVER_GAUDI3_HLS3_FULLSCALE_OUT = 9,
	HL_SERVER_GAUDI3_HLS3_FULL_OAM_3PORTS_SCALE_OUT = 10,
	HL_SERVER_GAUDI3_HLS3_FULL_OAM_6PORTS_SCALE_OUT = 11,
	HL_SERVER_GAUDI3_HLS3_SINGLEPORT_OAM_FULLSCALE_OUT = 12,
	HL_SERVER_GAUDI3_HL338 = 13,
};

/*
 * Notifier event values - for the notification mechanism and the HL_INFO_GET_EVENTS command
 *
 * HL_NOTIFIER_EVENT_TPC_ASSERT		- Indicates TPC assert event
 * HL_NOTIFIER_EVENT_UNDEFINED_OPCODE	- Indicates undefined operation code
 * HL_NOTIFIER_EVENT_DEVICE_RESET	- Indicates device requires a reset
 * HL_NOTIFIER_EVENT_CS_TIMEOUT		- Indicates CS timeout error
 * HL_NOTIFIER_EVENT_DEVICE_UNAVAILABLE	- Indicates device is unavailable
 * HL_NOTIFIER_EVENT_USER_ENGINE_ERR	- Indicates device engine in error state
 * HL_NOTIFIER_EVENT_GENERAL_HW_ERR     - Indicates device HW error
 * HL_NOTIFIER_EVENT_RAZWI              - Indicates razwi happened
 * HL_NOTIFIER_EVENT_PAGE_FAULT         - Indicates page fault happened
 * HL_NOTIFIER_EVENT_CRITICAL_HW_ERR    - Indicates a HW error that requires SW abort and
 *                                        HW reset
 * HL_NOTIFIER_EVENT_CRITICAL_FW_ERR    - Indicates a FW error that requires SW abort and
 *                                        HW reset
 */
#define HL_NOTIFIER_EVENT_TPC_ASSERT		(1ULL << 0)
#define HL_NOTIFIER_EVENT_UNDEFINED_OPCODE	(1ULL << 1)
#define HL_NOTIFIER_EVENT_DEVICE_RESET		(1ULL << 2)
#define HL_NOTIFIER_EVENT_CS_TIMEOUT		(1ULL << 3)
#define HL_NOTIFIER_EVENT_DEVICE_UNAVAILABLE	(1ULL << 4)
#define HL_NOTIFIER_EVENT_USER_ENGINE_ERR	(1ULL << 5)
#define HL_NOTIFIER_EVENT_GENERAL_HW_ERR	(1ULL << 6)
#define HL_NOTIFIER_EVENT_RAZWI			(1ULL << 7)
#define HL_NOTIFIER_EVENT_PAGE_FAULT		(1ULL << 8)
#define HL_NOTIFIER_EVENT_CRITICL_HW_ERR	(1ULL << 9)
#define HL_NOTIFIER_EVENT_CRITICL_FW_ERR	(1ULL << 10)

/* Opcode for management ioctl
 *
 * HW_IP_INFO            - Receive information about different IP blocks in the
 *                         device.
 * HL_INFO_HW_EVENTS     - Receive an array describing how many times each event
 *                         occurred since the last hard reset.
 * HL_INFO_DRAM_USAGE    - Retrieve the dram usage inside the device and of the
 *                         specific context. This is relevant only for devices
 *                         where the dram is managed by the kernel driver
 * HL_INFO_HW_IDLE       - Retrieve information about the idle status of each
 *                         internal engine.
 * HL_INFO_DEVICE_STATUS - Retrieve the device's status. This opcode doesn't
 *                         require an open context.
 * HL_INFO_DEVICE_UTILIZATION  - Retrieve the total utilization of the device
 *                               over the last period specified by the user.
 *                               The period can be between 100ms to 1s, in
 *                               resolution of 100ms. The return value is a
 *                               percentage of the utilization rate.
 * HL_INFO_HW_EVENTS_AGGREGATE - Receive an array describing how many times each
 *                               event occurred since the driver was loaded.
 * HL_INFO_CLK_RATE            - Retrieve the current and maximum clock rate
 *                               of the device in MHz. The maximum clock rate is
 *                               configurable via sysfs parameter
 * HL_INFO_RESET_COUNT   - Retrieve the counts of the soft and hard reset
 *                         operations performed on the device since the last
 *                         time the driver was loaded.
 * HL_INFO_TIME_SYNC     - Retrieve the device's time alongside the host's time
 *                         for synchronization.
 * HL_INFO_CS_COUNTERS   - Retrieve command submission counters
 * HL_INFO_PCI_COUNTERS  - Retrieve PCI counters
 * HL_INFO_CLK_THROTTLE_REASON - Retrieve clock throttling reason
 * HL_INFO_SYNC_MANAGER  - Retrieve sync manager info per dcore
 * HL_INFO_TOTAL_ENERGY  - Retrieve total energy consumption
 * HL_INFO_PLL_FREQUENCY - Retrieve PLL frequency
 * HL_INFO_POWER         - Retrieve power information
 * HL_INFO_OPEN_STATS    - Retrieve info regarding recent device open calls
 * HL_INFO_HABANA_LINK_STATE - Retrieve Habana link state
 * HL_INFO_HABANA_LINK_COUNTERS - Retrieve Habana link counters
 * HL_INFO_DRAM_REPLACED_ROWS - Retrieve DRAM replaced rows info
 * HL_INFO_DRAM_PENDING_ROWS - Retrieve DRAM pending rows num
 * HL_INFO_LAST_ERR_OPEN_DEV_TIME - Retrieve timestamp of the last time the device was opened
 *                                  and CS timeout or razwi error occurred.
 * HL_INFO_CS_TIMEOUT_EVENT - Retrieve CS timeout timestamp and its related CS sequence number.
 * HL_INFO_RAZWI_EVENT - Retrieve parameters of razwi:
 *                            Timestamp of razwi.
 *                            The address which accessing it caused the razwi.
 *                            Razwi initiator.
 *                            Razwi cause, was it a page fault or MMU access error.
 *                            May return 0 even though no new data is available, in that case
 *                            timestamp will be 0.
 * HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES - Retrieve valid page sizes for device memory allocation
 * HL_INFO_SECURED_ATTESTATION - Retrieve attestation report of the boot.
 * HL_INFO_REGISTER_EVENTFD   - Register eventfd for event notifications.
 * HL_INFO_UNREGISTER_EVENTFD - Unregister eventfd
 * HL_INFO_GET_EVENTS         - Retrieve the last occurred events
 * HL_INFO_UNDEFINED_OPCODE_EVENT - Retrieve last undefined opcode error information.
 *                                  May return 0 even though no new data is available, in that case
 *                                  timestamp will be 0.
 * HL_INFO_ENGINE_STATUS - Retrieve the status of all the h/w engines in the asic.
 * HL_INFO_PAGE_FAULT_EVENT - Retrieve parameters of captured page fault.
 *                            May return 0 even though no new data is available, in that case
 *                            timestamp will be 0.
 * HL_INFO_USER_MAPPINGS - Retrieve user mappings, captured after page fault event.
 * HL_INFO_FW_GENERIC_REQ - Send generic request to FW.
 * HL_INFO_HW_ERR_EVENT   - Retrieve information on the reported HW error.
 *                          May return 0 even though no new data is available, in that case
 *                          timestamp will be 0.
 * HL_INFO_FW_ERR_EVENT   - Retrieve information on the reported FW error.
 *                          May return 0 even though no new data is available, in that case
 *                          timestamp will be 0.
 * HL_INFO_USER_ENGINE_ERR_EVENT - Retrieve the last engine id that reported an error.
 * HL_INFO_MODULE_PARAMS - Retrieve the device's actual values of module
 *                         parameters.
 */
#define HL_INFO_HW_IP_INFO			0
#define HL_INFO_HW_EVENTS			1
#define HL_INFO_DRAM_USAGE			2
#define HL_INFO_HW_IDLE				3
#define HL_INFO_DEVICE_STATUS			4
#define HL_INFO_DEVICE_UTILIZATION		6
#define HL_INFO_HW_EVENTS_AGGREGATE		7
#define HL_INFO_CLK_RATE			8
#define HL_INFO_RESET_COUNT			9
#define HL_INFO_TIME_SYNC			10
#define HL_INFO_CS_COUNTERS			11
#define HL_INFO_PCI_COUNTERS			12
#define HL_INFO_CLK_THROTTLE_REASON		13
#define HL_INFO_SYNC_MANAGER			14
#define HL_INFO_TOTAL_ENERGY			15
#define HL_INFO_PLL_FREQUENCY			16
#define HL_INFO_POWER				17
#define HL_INFO_OPEN_STATS			18
#define HL_INFO_HABANA_LINK_STATE		19
#define HL_INFO_HABANA_LINK_COUNTERS		20
#define HL_INFO_DRAM_REPLACED_ROWS		21
#define HL_INFO_DRAM_PENDING_ROWS		22
#define HL_INFO_LAST_ERR_OPEN_DEV_TIME		23
#define HL_INFO_CS_TIMEOUT_EVENT		24
#define HL_INFO_RAZWI_EVENT			25
#define HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES	26
#define HL_INFO_SECURED_ATTESTATION		27
#define HL_INFO_REGISTER_EVENTFD		28
#define HL_INFO_UNREGISTER_EVENTFD		29
#define HL_INFO_GET_EVENTS			30
#define HL_INFO_UNDEFINED_OPCODE_EVENT		31
#define HL_INFO_ENGINE_STATUS			32
#define HL_INFO_PAGE_FAULT_EVENT		33
#define HL_INFO_USER_MAPPINGS			34
#define HL_INFO_FW_GENERIC_REQ			35
#define HL_INFO_HW_ERR_EVENT			36
#define HL_INFO_FW_ERR_EVENT			37
#define HL_INFO_USER_ENGINE_ERR_EVENT		38
#define HL_INFO_TIME_SYNC_PER_DIE		39
#define HL_INFO_DEV_SIGNED			40
#define HL_INFO_MODULE_PARAMS			255

#define HL_INFO_VERSION_MAX_LEN			128
#define HL_INFO_CARD_NAME_MAX_LEN		16

#define HL_INFO_MAC_ADDR_MAX_NUM		128

/* Maximum buffer size for retrieving engines status */
#define HL_ENGINES_DATA_MAX_SIZE	SZ_1M

/**
 * struct hl_info_hw_ip_info - hardware information on various IPs in the ASIC
 * @sram_base_address: The first SRAM physical base address that is free to be
 *                     used by the user.
 * @dram_base_address: The first DRAM virtual or physical base address that is
 *                     free to be used by the user.
 * @dram_size: The DRAM size that is available to the user.
 * @sram_size: The SRAM size that is available to the user.
 * @num_of_events: The number of events that can be received from the f/w. This
 *                 is needed so the user can what is the size of the h/w events
 *                 array he needs to pass to the kernel when he wants to fetch
 *                 the event counters.
 * @device_id: PCI device ID of the ASIC.
 * @module_id: Module ID of the ASIC for mezzanine cards in servers
 *             (From OCP spec).
 * @decoder_enabled_mask: Bit-mask that represents which decoders are enabled.
 * @first_available_interrupt_id: The first available interrupt ID for the user
 *                                to be used when it works with user interrupts.
 *                                Relevant for Gaudi2 and later.
 * @server_type: Server type that the Gaudi ASIC is currently installed in.
 *               The value is according to enum hl_server_type
 * @cpld_version: CPLD version on the board.
 * @psoc_pci_pll_nr: PCI PLL NR value. Needed by the profiler in some ASICs.
 * @psoc_pci_pll_nf: PCI PLL NF value. Needed by the profiler in some ASICs.
 * @psoc_pci_pll_od: PCI PLL OD value. Needed by the profiler in some ASICs.
 * @psoc_pci_pll_div_factor: PCI PLL DIV factor value. Needed by the profiler
 *                           in some ASICs.
 * @tpc_enabled_mask: Bit-mask that represents which TPCs are enabled. Relevant
 *                    for Goya/Gaudi only.
 * @dram_enabled: Whether the DRAM is enabled.
 * @security_enabled: Whether security is enabled on device.
 * @mme_master_slave_mode: Indicate whether the MME is working in master/slave
 *                         configuration. Relevant for Gaudi2 and later.
 * @cpucp_version: The CPUCP f/w version.
 * @card_name: The card name as passed by the f/w.
 * @tpc_enabled_mask_ext: Bit-mask that represents which TPCs are enabled.
 *                        Relevant for Gaudi2 and later.
 * @dram_page_size: The DRAM physical page size.
 * @edma_enabled_mask: Bit-mask that represents which EDMAs are enabled.
 *                     Relevant for Gaudi2 and later.
 * @number_of_user_interrupts: The number of interrupts that are available to the userspace
 *                             application to use. Relevant for Gaudi2 and later.
 * @interposer_version: Interposer version.
 * @substrate_version: Substrate version.
 * @pdma_user_owned_ch_mask: Bit-mask that represents which PDMA channels are
 *                           enabled and can be used by the user.
 * @device_mem_alloc_default_page_size: default page size used in device memory allocation.
 * @nic_ports_mask: Bit mask that represents the nic ports that are enabled.
 * @nic_ports_external_mask: Bit mask that represents the nic ports that are external - used for
 *                           scale-out and are exposed to Linux as network devices.
 * @mme_enabled_mask: Bit-mask that represents which MMEs are enabled.
 * @odp_supported: true if ODP is supported, otherwise false.
 * @revision_id: PCI revision ID of the ASIC.
 * @tpc_interrupt_id: interrupt id for TPC to use in order to raise events towards the host.
 * @rotator_enabled_mask: Bit-mask that represents which rotators are enabled.
 *                        Relevant for Gaudi3 and later.
 * @sched_arc_enabled_mask: Bit-mask that represents which Sched arcs are enabled.
 * @engine_core_interrupt_reg_addr: interrupt register address for engine core to use
 *                                  in order to raise events toward FW.
 * @reserved_dram_size: DRAM size reserved for driver and firmware.
 */
struct hl_info_hw_ip_info {
	__u64 sram_base_address;
	__u64 dram_base_address;
	__u64 dram_size;
	__u32 sram_size;
	__u32 num_of_events;
	__u32 device_id;
	__u32 module_id;
	__u32 decoder_enabled_mask;
	__u16 first_available_interrupt_id;
	__u16 server_type;
	__u32 cpld_version;
	__u32 psoc_pci_pll_nr;
	__u32 psoc_pci_pll_nf;
	__u32 psoc_pci_pll_od;
	__u32 psoc_pci_pll_div_factor;
	__u8 tpc_enabled_mask;
	__u8 dram_enabled;
	__u8 security_enabled;
	__u8 mme_master_slave_mode;
	__u8 cpucp_version[HL_INFO_VERSION_MAX_LEN];
	__u8 card_name[HL_INFO_CARD_NAME_MAX_LEN];
	__u64 tpc_enabled_mask_ext;
	__u64 dram_page_size;
	__u32 edma_enabled_mask;
	__u16 number_of_user_interrupts;
	__u8 interposer_version;
	__u8 substrate_version;
	__u64 pdma_user_owned_ch_mask;
	__u64 device_mem_alloc_default_page_size;
	__u64 nic_ports_mask;
	__u64 nic_ports_external_mask;
	__u32 mme_enabled_mask;
	__u8 odp_supported;
	__u8 revision_id;
	__u16 tpc_interrupt_id;
	__u32 rotator_enabled_mask;
	__u32 sched_arc_enabled_mask;
	__u64 engine_core_interrupt_reg_addr;
	__u64 reserved_dram_size;
};

struct hl_info_dram_usage {
	__u64 dram_free_mem;
	__u64 ctx_dram_mem;
};

#define HL_BUSY_ENGINES_MASK_EXT_SIZE	4

struct hl_info_hw_idle {
	__u32 is_idle;
	/*
	 * Bitmask of busy engines.
	 * Bits definition is according to `enum <chip>_engine_id'.
	 */
	__u32 busy_engines_mask;

	/*
	 * Extended Bitmask of busy engines.
	 * Bits definition is according to `enum <chip>_engine_id'.
	 */
	__u64 busy_engines_mask_ext[HL_BUSY_ENGINES_MASK_EXT_SIZE];
};

struct hl_info_device_status {
	__u32 status;
	__u32 pad;
};

struct hl_info_device_utilization {
	__u32 utilization;
	__u32 pad;
};

struct hl_info_clk_rate {
	__u32 cur_clk_rate_mhz;
	__u32 max_clk_rate_mhz;
};

struct hl_info_reset_count {
	__u32 hard_reset_cnt;
	__u32 soft_reset_cnt;
};

struct hl_info_time_sync {
	__u64 device_time;
	__u64 host_time;
	__u64 tsc_time;
};

struct hl_info_time_sync_per_die {
	__u32 die_index;
	__u32 pad;
	__u64 device_time;
	__u64 host_time;
	__u64 tsc_time;
};

/**
 * struct hl_info_pci_counters - pci counters
 * @rx_throughput: PCI rx throughput KBps
 * @tx_throughput: PCI tx throughput KBps
 * @replay_cnt: PCI replay counter
 */
struct hl_info_pci_counters {
	__u64 rx_throughput;
	__u64 tx_throughput;
	__u64 replay_cnt;
};

enum hl_clk_throttling_type {
	HL_CLK_THROTTLE_TYPE_POWER,
	HL_CLK_THROTTLE_TYPE_THERMAL,
	HL_CLK_THROTTLE_TYPE_MAX
};

/* clk_throttling_reason masks */
#define HL_CLK_THROTTLE_POWER		(1 << HL_CLK_THROTTLE_TYPE_POWER)
#define HL_CLK_THROTTLE_THERMAL		(1 << HL_CLK_THROTTLE_TYPE_THERMAL)

/**
 * struct hl_info_clk_throttle - clock throttling reason
 * @clk_throttling_reason: each bit represents a clk throttling reason
 * @clk_throttling_timestamp_us: represents CPU timestamp in microseconds of the start-event
 * @clk_throttling_duration_ns: the clock throttle time in nanosec
 */
struct hl_info_clk_throttle {
	__u32 clk_throttling_reason;
	__u32 pad;
	__u64 clk_throttling_timestamp_us[HL_CLK_THROTTLE_TYPE_MAX];
	__u64 clk_throttling_duration_ns[HL_CLK_THROTTLE_TYPE_MAX];
};

/**
 * struct hl_info_energy - device energy information
 * @total_energy_consumption: total device energy consumption
 */
struct hl_info_energy {
	__u64 total_energy_consumption;
};

#define HL_PLL_NUM_OUTPUTS 4

struct hl_pll_frequency_info {
	__u16 output[HL_PLL_NUM_OUTPUTS];
};

/**
 * struct hl_open_stats_info - device open statistics information
 * @open_counter: ever growing counter, increased on each successful dev open
 * @last_open_period_ms: duration (ms) device was open last time
 * @is_compute_ctx_active: Whether there is an active compute context executing
 * @compute_ctx_in_release: true if the current compute context is being released
 * @compute_ctx_has_mapped_resources: true if the current compute context has mapped resources
 */
struct hl_open_stats_info {
	__u64 open_counter;
	__u64 last_open_period_ms;
	__u8 is_compute_ctx_active;
	__u8 compute_ctx_in_release;
	__u8 compute_ctx_has_mapped_resources;
	__u8 pad[5];
};

/**
 * struct hl_power_info - power information
 * @power: power consumption
 */
struct hl_power_info {
	__u64 power;
};

/**
 * struct hl_info_sync_manager - sync manager information
 * @first_available_sync_object: first available sob
 * @first_available_monitor: first available monitor
 * @first_available_cq: first available cq
 */
struct hl_info_sync_manager {
	__u32 first_available_sync_object;
	__u32 first_available_monitor;
	__u32 first_available_cq;
	__u32 reserved;
};

/**
 * struct hl_info_cs_counters - command submission counters
 * @total_out_of_mem_drop_cnt: total dropped due to memory allocation issue
 * @ctx_out_of_mem_drop_cnt: context dropped due to memory allocation issue
 * @total_parsing_drop_cnt: total dropped due to error in packet parsing
 * @ctx_parsing_drop_cnt: context dropped due to error in packet parsing
 * @total_queue_full_drop_cnt: total dropped due to queue full
 * @ctx_queue_full_drop_cnt: context dropped due to queue full
 * @total_device_in_reset_drop_cnt: total dropped due to device in reset
 * @ctx_device_in_reset_drop_cnt: context dropped due to device in reset
 * @total_max_cs_in_flight_drop_cnt: total dropped due to maximum CS in-flight
 * @ctx_max_cs_in_flight_drop_cnt: context dropped due to maximum CS in-flight
 * @total_validation_drop_cnt: total dropped due to validation error
 * @ctx_validation_drop_cnt: context dropped due to validation error
 */
struct hl_info_cs_counters {
	__u64 total_out_of_mem_drop_cnt;
	__u64 ctx_out_of_mem_drop_cnt;
	__u64 total_parsing_drop_cnt;
	__u64 ctx_parsing_drop_cnt;
	__u64 total_queue_full_drop_cnt;
	__u64 ctx_queue_full_drop_cnt;
	__u64 total_device_in_reset_drop_cnt;
	__u64 ctx_device_in_reset_drop_cnt;
	__u64 total_max_cs_in_flight_drop_cnt;
	__u64 ctx_max_cs_in_flight_drop_cnt;
	__u64 total_validation_drop_cnt;
	__u64 ctx_validation_drop_cnt;
};

struct hl_info_module_params {
	__u64 tpc_mask;
	__u32 gaudi_huge_page_optimization;
	__u32 timeout_locked;
	__u32 reset_on_lockup;
	__u32 pldm;
	__u32 mmu_enable;
	__u32 clock_gating;
	__u32 mme_enable;
	__u32 nic_ports_mask;
	__u32 dram_enable;
	__u32 cpu_enable;
	__u32 reset_pcilink;
	__u32 config_pll;
	__u32 cpu_queues_enable;
	__u32 fw_loading;
	__u32 heartbeat;
	__u32 axi_drain;
	__u32 security_enable;
	__u32 sram_scrambler_enable;
	__u32 dram_scrambler_enable;
	__u32 cache_enabled;
	__u32 hbm_ecc_enable;
	__u32 compatibility_mode;
	__u32 hard_reset_on_fw_events;
	__u32 decoder_mask;
	__u32 rotator_mask;
	__u32 dram_page_scrub;
	__u32 clock_gating_ext;
	__u32 fw_loading_ext;
	__u32 nic_lanes_per_port;
};

/**
 * enum hl_link_qual - Quality of a link
 * HL_LINK_QUAL_POOR: Poor link quality.
 * HL_LINK_QUAL_GOOD: Good link quality.
 * HL_LINK_QUAL_EXCELLENT: Excellent link quality.
 */
enum hl_link_qual {
	HL_LINK_QUAL_POOR,
	HL_LINK_QUAL_GOOD,
	HL_LINK_QUAL_EXCELLENT,
};

/**
 * struct hl_info_habana_link_state - Get Habana link state.
 * @up: Boolean for indicating if the link is up.
 * @port_open: Boolean for indicating if the port is open.
 * @link_qual: Quality of link as defined in hl_link_qual.
 * @pad: Padding to 64 bit.
 */
struct hl_info_habana_link_state {
	__u8 up;
	__u8 port_open;
	__u8 link_qual;
	__u8 pad[5];
};

#define HABANA_LINK_CNT_MAX_NUM	256
#define HABANA_LINK_STR_LEN	32

/**
 * struct hl_info_habana_link_counters - Get Habana link counters.
 * @str_buf_ptr: User space address of buffer to hold the counters names. Recommended size is
 *               HABANA_LINK_STR_LEN * HABANA_LINK_CNT_MAX_NUM.
 * @val_buf_ptr: User space address of buffer to hold the counters values. Recommended size is
 *               sizeof(__u64) * HABANA_LINK_CNT_MAX_NUM.
 * @num_of_stat: Number of counters that were actually fetched.
 * @pad: Padding to 64 bit.
 */
struct hl_info_habana_link_counters {
	__u64 str_buf_ptr;
	__u64 val_buf_ptr;
	__u32 num_of_stat;
	__u32 pad;
};

/**
 * struct hl_info_last_err_open_dev_time - last error boot information.
 * @timestamp: timestamp of last time the device was opened and error occurred.
 */
struct hl_info_last_err_open_dev_time {
	__s64 timestamp;
};

/**
 * struct hl_info_cs_timeout_event - last CS timeout information.
 * @timestamp: timestamp when last CS timeout event occurred.
 * @seq: sequence number of last CS timeout event.
 */
struct hl_info_cs_timeout_event {
	__s64 timestamp;
	__u64 seq;
};

#define HL_RAZWI_NA_ENG_ID U16_MAX
#define HL_RAZWI_MAX_NUM_OF_ENGINES_PER_RTR 128
#define HL_RAZWI_READ		BIT(0)
#define HL_RAZWI_WRITE		BIT(1)
#define HL_RAZWI_LBW		BIT(2)
#define HL_RAZWI_HBW		BIT(3)
#define HL_RAZWI_RR		BIT(4)
#define HL_RAZWI_ADDR_DEC	BIT(5)

/**
 * struct hl_info_razwi_event - razwi information.
 * @timestamp: timestamp of razwi.
 * @addr: address which accessing it caused razwi.
 * @engine_id: engine id of the razwi initiator, if it was initiated by engine that does not
 *             have engine id it will be set to HL_RAZWI_NA_ENG_ID. If there are several possible
 *             engines which caused the razwi, it will hold all of them.
 * @num_of_possible_engines: contains number of possible engine ids. In some asics, razwi indication
 *                           might be common for several engines and there is no way to get the
 *                           exact engine. In this way, engine_id array will be filled with all
 *                           possible engines caused this razwi. Also, there might be possibility
 *                           in gaudi, where we don't indication on specific engine, in that case
 *                           the value of this parameter will be zero.
 * @flags: bitmask for additional data: HL_RAZWI_READ - razwi caused by read operation
 *                                      HL_RAZWI_WRITE - razwi caused by write operation
 *                                      HL_RAZWI_LBW - razwi caused by lbw fabric transaction
 *                                      HL_RAZWI_HBW - razwi caused by hbw fabric transaction
 *                                      HL_RAZWI_RR - razwi caused by range register
 *                                      HL_RAZWI_ADDR_DEC - razwi caused by address decode error
 *         Note: this data is not supported by all asics, in that case the relevant bits will not
 *               be set.
 */
struct hl_info_razwi_event {
	__s64 timestamp;
	__u64 addr;
	__u16 engine_id[HL_RAZWI_MAX_NUM_OF_ENGINES_PER_RTR];
	__u16 num_of_possible_engines;
	__u8 flags;
	__u8 pad[5];
};

#define MAX_QMAN_STREAMS_INFO		4
#define OPCODE_INFO_MAX_ADDR_SIZE	8
/**
 * struct hl_info_undefined_opcode_event - info about last undefined opcode error
 * @timestamp: timestamp of the undefined opcode error
 * @cb_addr_streams: CB addresses (per stream) that are currently exists in the PQ
 *                   entries. In case all streams array entries are
 *                   filled with values, it means the execution was in Lower-CP.
 * @cq_addr: the address of the current handled command buffer
 * @cq_size: the size of the current handled command buffer
 * @cb_addr_streams_len: num of streams - actual len of cb_addr_streams array.
 *                       should be equal to 1 in case of undefined opcode
 *                       in Upper-CP (specific stream) and equal to 4 incase
 *                       of undefined opcode in Lower-CP.
 * @engine_id: engine-id that the error occurred on
 * @stream_id: the stream id the error occurred on. In case the stream equals to
 *             MAX_QMAN_STREAMS_INFO it means the error occurred on a Lower-CP.
 */
struct hl_info_undefined_opcode_event {
	__s64 timestamp;
	__u64 cb_addr_streams[MAX_QMAN_STREAMS_INFO][OPCODE_INFO_MAX_ADDR_SIZE];
	__u64 cq_addr;
	__u32 cq_size;
	__u32 cb_addr_streams_len;
	__u32 engine_id;
	__u32 stream_id;
};

/**
 * struct hl_info_hw_err_event - info about HW error
 * @timestamp: timestamp of error occurrence
 * @event_id: The async event ID (specific to each device type).
 * @pad: size padding for u64 granularity.
 */
struct hl_info_hw_err_event {
	__s64 timestamp;
	__u16 event_id;
	__u16 pad[3];
};

/* FW error definition for event_type in struct hl_info_fw_err_event */
enum hl_info_fw_err_type {
	HL_INFO_FW_HEARTBEAT_ERR,
	HL_INFO_FW_REPORTED_ERR,
};

/**
 * struct hl_info_fw_err_event - info about FW error
 * @timestamp: time-stamp of error occurrence
 * @err_type: The type of event as defined in hl_info_fw_err_type.
 * @event_id: The async event ID (specific to each device type, applicable only when event type is
 *             HL_INFO_FW_REPORTED_ERR).
 * @pad: size padding for u64 granularity.
 */
struct hl_info_fw_err_event {
	__s64 timestamp;
	__u16 err_type;
	__u16 event_id;
	__u32 pad;
};

/**
 * struct hl_info_engine_err_event - engine error info
 * @timestamp: time-stamp of error occurrence
 * @engine_id: engine id who reported the error.
 * @error_count: Amount of errors reported.
 * @pad: size padding for u64 granularity.
 */
struct hl_info_engine_err_event {
	__s64 timestamp;
	__u16 engine_id;
	__u16 error_count;
	__u32 pad;
};

/**
 * struct hl_info_dev_memalloc_page_sizes - valid page sizes in device mem alloc information.
 * @page_order_bitmask: bitmap in which a set bit represents the order of the supported page size
 *                      (e.g. 0x2100000 means that 1MB and 32MB pages are supported).
 */
struct hl_info_dev_memalloc_page_sizes {
	__u64 page_order_bitmask;
};

#define SEC_PCR_DATA_BUF_SZ	256
#define SEC_PCR_QUOTE_BUF_SZ	510	/* (512 - 2) 2 bytes used for size */
#define SEC_SIGNATURE_BUF_SZ	255	/* (256 - 1) 1 byte used for size */
#define SEC_PUB_DATA_BUF_SZ	510	/* (512 - 2) 2 bytes used for size */
#define SEC_CERTIFICATE_BUF_SZ	2046	/* (2048 - 2) 2 bytes used for size */
#define SEC_DEV_INFO_BUF_SZ	5120

/*
 * struct hl_info_sec_attest - attestation report of the boot
 * @nonce: number only used once. random number provided by host. this also passed to the quote
 *         command as a qualifying data.
 * @pcr_quote_len: length of the attestation quote data (bytes)
 * @pub_data_len: length of the public data (bytes)
 * @certificate_len: length of the certificate (bytes)
 * @pcr_num_reg: number of PCR registers in the pcr_data array
 * @pcr_reg_len: length of each PCR register in the pcr_data array (bytes)
 * @quote_sig_len: length of the attestation report signature (bytes)
 * @pcr_data: raw values of the PCR registers
 * @pcr_quote: attestation report data structure
 * @quote_sig: signature structure of the attestation report
 * @public_data: public key for the signed attestation
 *		 (outPublic + name + qualifiedName)
 * @certificate: certificate for the attestation signing key
 */
struct hl_info_sec_attest {
	__u32 nonce;
	__u16 pcr_quote_len;
	__u16 pub_data_len;
	__u16 certificate_len;
	__u8 pcr_num_reg;
	__u8 pcr_reg_len;
	__u8 quote_sig_len;
	__u8 pcr_data[SEC_PCR_DATA_BUF_SZ];
	__u8 pcr_quote[SEC_PCR_QUOTE_BUF_SZ];
	__u8 quote_sig[SEC_SIGNATURE_BUF_SZ];
	__u8 public_data[SEC_PUB_DATA_BUF_SZ];
	__u8 certificate[SEC_CERTIFICATE_BUF_SZ];
	__u8 pad0[2];
};

/*
 * struct hl_info_signed - device information signed by a secured device.
 * @nonce: number only used once. random number provided by host. this also passed to the quote
 *         command as a qualifying data.
 * @pub_data_len: length of the public data (bytes)
 * @certificate_len: length of the certificate (bytes)
 * @info_sig_len: length of the attestation signature (bytes)
 * @public_data: public key info signed info data (outPublic + name + qualifiedName)
 * @certificate: certificate for the signing key
 * @info_sig: signature of the info + nonce data.
 * @dev_info_len: length of device info (bytes)
 * @dev_info: device info as byte array.
 */
struct hl_info_signed {
	__u32 nonce;
	__u16 pub_data_len;
	__u16 certificate_len;
	__u8 info_sig_len;
	__u8 public_data[SEC_PUB_DATA_BUF_SZ];
	__u8 certificate[SEC_CERTIFICATE_BUF_SZ];
	__u8 info_sig[SEC_SIGNATURE_BUF_SZ];
	__u16 dev_info_len;
	__u8 dev_info[SEC_DEV_INFO_BUF_SZ];
	__u8 pad[2];
};

/**
 * struct hl_page_fault_info - page fault information.
 * @timestamp: timestamp of page fault.
 * @addr: address which accessing it caused page fault.
 * @engine_id: engine id which caused the page fault, supported only in gaudi3.
 */
struct hl_page_fault_info {
	__s64 timestamp;
	__u64 addr;
	__u16 engine_id;
	__u8 pad[6];
};

/**
 * struct hl_user_mapping - user mapping information.
 * @dev_va: device virtual address.
 * @size: virtual address mapping size.
 */
struct hl_user_mapping {
	__u64 dev_va;
	__u64 size;
};

enum gaudi_dcores {
	HL_GAUDI_WS_DCORE,
	HL_GAUDI_WN_DCORE,
	HL_GAUDI_EN_DCORE,
	HL_GAUDI_ES_DCORE
};

/**
 * struct hl_info_args - Main structure to retrieve device related information.
 * @return_pointer: User space address of the relevant structure related to HL_INFO_* operation
 *                  mentioned in @op.
 * @return_size: Size of the structure used in @return_pointer, just like "size" in "snprintf", it
 *               limits how many bytes the kernel can write. For hw_events array, the size should be
 *               hl_info_hw_ip_info.num_of_events * sizeof(__u32).
 * @op: Defines which type of information to be retrieved. Refer HL_INFO_* for details.
 * @dcore_id: DCORE id for which the information is relevant (for Gaudi refer to enum gaudi_dcores).
 * @ctx_id: Context ID of the user. Currently not in use.
 * @period_ms: Period value, in milliseconds, for utilization rate in range 100ms - 1000ms in 100 ms
 *             resolution. Currently not in use.
 * @pll_index: Index as defined in hl_<asic type>_pll_index enumeration.
 * @habana_link_id: Habana link id.
 * @eventfd: event file descriptor for event notifications.
 * @user_buffer_actual_size: Actual data size which was copied to user allocated buffer by the
 *                           driver. It is possible for the user to allocate buffer larger than
 *                           needed, hence updating this variable so user will know the exact amount
 *                           of bytes copied by the kernel to the buffer.
 * @sec_attest_nonce: Nonce number used for attestation report.
 * @array_size: Number of array members copied to user buffer.
 *              Relevant for HL_INFO_USER_MAPPINGS info ioctl.
 * @fw_sub_opcode: generic requests sub opcodes.
 * @pad: Padding to 64 bit.
 */
struct hl_info_args {
	__u64 return_pointer;
	__u32 return_size;
	__u32 op;

	union {
		__u32 dcore_id;
		__u32 ctx_id;
		__u32 period_ms;
		__u32 pll_index;
		__u32 habana_link_id;
		__u32 eventfd;
		__u32 user_buffer_actual_size;
		__u32 sec_attest_nonce;
		__u32 array_size;
		__u32 fw_sub_opcode;
	};

	__u32 pad;
};

/* Opcode to create a new command buffer */
#define HL_CB_OP_CREATE		0
/* Opcode to destroy previously created command buffer */
#define HL_CB_OP_DESTROY	1
/* Opcode to retrieve information about a command buffer */
#define HL_CB_OP_INFO		2

/* 2MB minus 32 bytes for 2xMSG_PROT */
#define HL_MAX_CB_SIZE		(0x200000 - 32)

/* Indicates whether the command buffer should be mapped to the device's MMU */
#define HL_CB_FLAGS_MAP			0x1

/* Used with HL_CB_OP_INFO opcode to get the device va address for kernel mapped CB */
#define HL_CB_FLAGS_GET_DEVICE_VA	0x2

struct hl_cb_in {
	/* Handle of CB or 0 if we want to create one */
	__u64 cb_handle;
	/* HL_CB_OP_* */
	__u32 op;

	/* Size of CB. Maximum size is HL_MAX_CB_SIZE. The minimum size that
	 * will be allocated, regardless of this parameter's value, is PAGE_SIZE
	 */
	__u32 cb_size;

	/* Context ID - Currently not in use */
	__u32 ctx_id;
	/* HL_CB_FLAGS_* */
	__u32 flags;
};

struct hl_cb_out {
	union {
		/* Handle of CB */
		__u64 cb_handle;

		union {
			/* Information about CB */
			struct {
				/* Usage count of CB */
				__u32 usage_cnt;
				__u32 pad;
			};

			/* CB mapped address to device MMU */
			__u64 device_va;
		};
	};
};

union hl_cb_args {
	struct hl_cb_in in;
	struct hl_cb_out out;
};

/* HL_CS_CHUNK_FLAGS_ values
 *
 * HL_CS_CHUNK_FLAGS_USER_ALLOC_CB:
 *      Indicates if the CB was allocated and mapped by userspace
 *      (relevant to Gaudi2 and later). User allocated CB is a command buffer,
 *      allocated by the user, via malloc (or similar). After allocating the
 *      CB, the user invokes - “memory ioctl” to map the user memory into a
 *      device virtual address. The user provides this address via the
 *      cb_handle field. The interface provides the ability to create a
 *      large CBs, Which aren’t limited to “HL_MAX_CB_SIZE”. Therefore, it
 *      increases the PCI-DMA queues throughput. This CB allocation method
 *      also reduces the use of Linux DMA-able memory pool. Which are limited
 *      and used by other Linux sub-systems.
 */
#define HL_CS_CHUNK_FLAGS_USER_ALLOC_CB 0x1

/*
 * This structure size must always be fixed to 64-bytes for backward
 * compatibility
 */
struct hl_cs_chunk {
	union {
		/* Goya/Gaudi:
		 * For external queue, this represents a Handle of CB on the
		 * Host.
		 * For internal queue in Goya, this represents an SRAM or
		 * a DRAM address of the internal CB. In Gaudi, this might also
		 * represent a mapped host address of the CB.
		 *
		 * Gaudi2 onwards:
		 * For H/W queue, this represents either a Handle of CB on the
		 * Host, or an SRAM, a DRAM, or a mapped host address of the CB.
		 *
		 * A mapped host address is in the device address space, after
		 * a host address was mapped by the device MMU.
		 */
		__u64 cb_handle;

		/* Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set
		 * This holds address of array of u64 values that contain
		 * signal CS sequence numbers. The wait described by
		 * this job will listen on all those signals
		 * (wait event per signal)
		 */
		__u64 signal_seq_arr;

		/*
		 * Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set
		 * along with HL_CS_FLAGS_ENCAP_SIGNALS.
		 * This is the CS sequence which has the encapsulated signals.
		 */
		__u64 encaps_signal_seq;
	};

	/* Index of queue to put the CB on */
	__u32 queue_index;

	union {
		/*
		 * Size of command buffer with valid packets
		 * Can be smaller then actual CB size
		 */
		__u32 cb_size;

		/* Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set.
		 * Number of entries in signal_seq_arr
		 */
		__u32 num_signal_seq_arr;

		/* Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set along
		 * with HL_CS_FLAGS_ENCAP_SIGNALS
		 * This set the signals range that the user want to wait for
		 * out of the whole reserved signals range.
		 * e.g if the signals range is 20, and user don't want
		 * to wait for signal 8, so he set this offset to 7, then
		 * he call the API again with 9 and so on till 20.
		 */
		__u32 encaps_signal_offset;
	};

	/* HL_CS_CHUNK_FLAGS_* */
	__u32 cs_chunk_flags;

	/* Relevant only when HL_CS_FLAGS_COLLECTIVE_WAIT is set.
	 * This holds the collective engine ID. The wait described by this job
	 * will sync with this engine and with all NICs before completion.
	 */
	__u32 collective_engine_id;

	/* Align structure to 64 bytes */
	__u32 pad[10];
};

/* SIGNAL/WAIT/COLLECTIVE_WAIT flags are mutually exclusive */
#define HL_CS_FLAGS_FORCE_RESTORE		0x1
#define HL_CS_FLAGS_SIGNAL			0x2
#define HL_CS_FLAGS_WAIT			0x4
#define HL_CS_FLAGS_COLLECTIVE_WAIT		0x8

#define HL_CS_FLAGS_TIMESTAMP			0x20
#define HL_CS_FLAGS_STAGED_SUBMISSION		0x40
#define HL_CS_FLAGS_STAGED_SUBMISSION_FIRST	0x80
#define HL_CS_FLAGS_STAGED_SUBMISSION_LAST	0x100
#define HL_CS_FLAGS_CUSTOM_TIMEOUT		0x200
#define HL_CS_FLAGS_SKIP_RESET_ON_TIMEOUT	0x400

/*
 * The encapsulated signals CS is merged into the existing CS ioctls.
 * In order to use this feature need to follow the below procedure:
 * 1. Reserve signals, set the CS type to HL_CS_FLAGS_RESERVE_SIGNALS_ONLY
 *    the output of this API will be the SOB offset from CFG_BASE.
 *    this address will be used to patch CB cmds to do the signaling for this
 *    SOB by incrementing it's value.
 *    for reverting the reservation use HL_CS_FLAGS_UNRESERVE_SIGNALS_ONLY
 *    CS type, note that this might fail if out-of-sync happened to the SOB
 *    value, in case other signaling request to the same SOB occurred between
 *    reserve-unreserve calls.
 * 2. Use the staged CS to do the encapsulated signaling jobs.
 *    use HL_CS_FLAGS_STAGED_SUBMISSION and HL_CS_FLAGS_STAGED_SUBMISSION_FIRST
 *    along with HL_CS_FLAGS_ENCAP_SIGNALS flag, and set encaps_signal_offset
 *    field. This offset allows app to wait on part of the reserved signals.
 * 3. Use WAIT/COLLECTIVE WAIT CS along with HL_CS_FLAGS_ENCAP_SIGNALS flag
 *    to wait for the encapsulated signals.
 */
#define HL_CS_FLAGS_ENCAP_SIGNALS		0x800
#define HL_CS_FLAGS_RESERVE_SIGNALS_ONLY	0x1000
#define HL_CS_FLAGS_UNRESERVE_SIGNALS_ONLY	0x2000

/*
 * The engine cores CS is merged into the existing CS ioctls.
 * Use it to control the engine cores mode.
 */
#define HL_CS_FLAGS_ENGINE_CORE_COMMAND		0x4000

/*
 * The flush HBW PCI writes is merged into the existing CS ioctls.
 * Used to flush all HBW PCI writes.
 * This is a blocking operation and for this reason the user shall not use
 * the return sequence number (which will be invalid anyway)
 */
#define HL_CS_FLAGS_FLUSH_PCI_HBW_WRITES	0x8000

/*
 * The engines CS is merged into the existing CS ioctls.
 * Use it to control engines modes.
 */
#define HL_CS_FLAGS_ENGINES_COMMAND		0x10000

#define HL_CS_STATUS_SUCCESS		0

#define HL_MAX_JOBS_PER_CS		512

/*
 * enum hl_engine_command - engine command
 *
 * @HL_ENGINE_CORE_HALT: engine core halt
 * @HL_ENGINE_CORE_RUN: engine core run
 * @HL_ENGINE_STALL: user engine/s stall
 * @HL_ENGINE_RESUME: user engine/s resume
 */
enum hl_engine_command {
	HL_ENGINE_CORE_HALT = 1,
	HL_ENGINE_CORE_RUN = 2,
	HL_ENGINE_STALL = 3,
	HL_ENGINE_RESUME = 4,
	HL_ENGINE_COMMAND_MAX
};

struct hl_cs_in {

	union {
		struct {
			/* this holds address of array of hl_cs_chunk for restore phase */
			__u64 chunks_restore;

			/* holds address of array of hl_cs_chunk for execution phase */
			__u64 chunks_execute;
		};

		/* Valid only when HL_CS_FLAGS_ENGINE_CORE_COMMAND is set */
		struct {
			/* this holds address of array of uint32 for engine_cores */
			__u64 engine_cores;

			/* number of engine cores in engine_cores array */
			__u32 num_engine_cores;

			/* the core command to be sent towards engine cores */
			__u32 core_command;
		};

		/* Valid only when HL_CS_FLAGS_ENGINES_COMMAND is set */
		struct {
			/* this holds address of array of uint32 for engines */
			__u64 engines;

			/* number of engines in engines array */
			__u32 num_engines;

			/* the engine command to be sent towards engines */
			__u32 engine_command;
		};
	};

	union {
		/*
		 * Sequence number of a staged submission CS
		 * valid only if HL_CS_FLAGS_STAGED_SUBMISSION is set and
		 * HL_CS_FLAGS_STAGED_SUBMISSION_FIRST is unset.
		 */
		__u64 seq;

		/*
		 * Encapsulated signals handle id
		 * Valid for two flows:
		 * 1. CS with encapsulated signals:
		 *    when HL_CS_FLAGS_STAGED_SUBMISSION and
		 *    HL_CS_FLAGS_STAGED_SUBMISSION_FIRST
		 *    and HL_CS_FLAGS_ENCAP_SIGNALS are set.
		 * 2. unreserve signals:
		 *    valid when HL_CS_FLAGS_UNRESERVE_SIGNALS_ONLY is set.
		 */
		__u32 encaps_sig_handle_id;

		/* Valid only when HL_CS_FLAGS_RESERVE_SIGNALS_ONLY is set */
		struct {
			/* Encapsulated signals number */
			__u32 encaps_signals_count;

			/* Encapsulated signals queue index (stream) */
			__u32 encaps_signals_q_idx;
		};
	};

	/* Number of chunks in restore phase array. Maximum number is
	 * HL_MAX_JOBS_PER_CS
	 */
	__u32 num_chunks_restore;

	/* Number of chunks in execution array. Maximum number is
	 * HL_MAX_JOBS_PER_CS
	 */
	__u32 num_chunks_execute;

	/* timeout in seconds - valid only if HL_CS_FLAGS_CUSTOM_TIMEOUT
	 * is set
	 */
	__u32 timeout;

	/* HL_CS_FLAGS_* */
	__u32 cs_flags;

	/* Context ID - Currently not in use */
	__u32 ctx_id;
	__u8 pad[4];
};

struct hl_cs_out {
	union {
		/*
		 * seq holds the sequence number of the CS to pass to wait
		 * ioctl. All values are valid except for 0 and ULLONG_MAX
		 */
		__u64 seq;

		/* Valid only when HL_CS_FLAGS_RESERVE_SIGNALS_ONLY is set */
		struct {
			/* This is the reserved signal handle id */
			__u32 handle_id;

			/* This is the signals count */
			__u32 count;
		};
	};

	/* HL_CS_STATUS */
	__u32 status;

	/*
	 * SOB base address offset
	 * Valid only when HL_CS_FLAGS_RESERVE_SIGNALS_ONLY or HL_CS_FLAGS_SIGNAL is set
	 */
	__u32 sob_base_addr_offset;

	/*
	 * Count of completed signals in SOB before current signal submission.
	 * Valid only when (HL_CS_FLAGS_ENCAP_SIGNALS & HL_CS_FLAGS_STAGED_SUBMISSION)
	 * or HL_CS_FLAGS_SIGNAL is set
	 */
	__u16 sob_count_before_submission;
	__u16 pad[3];
};

union hl_cs_args {
	struct hl_cs_in in;
	struct hl_cs_out out;
};

#define HL_WAIT_CS_FLAGS_INTERRUPT		0x2
#define HL_WAIT_CS_FLAGS_INTERRUPT_MASK		0xFFF00000
#define HL_WAIT_CS_FLAGS_ANY_CQ_INTERRUPT	0xFFF00000
#define HL_WAIT_CS_FLAGS_ANY_DEC_INTERRUPT	0xFFE00000
#define HL_WAIT_CS_FLAGS_MULTI_CS		0x4
#define HL_WAIT_CS_FLAGS_INTERRUPT_KERNEL_CQ	0x10
#define HL_WAIT_CS_FLAGS_REGISTER_INTERRUPT	0x20

#define HL_WAIT_MULTI_CS_LIST_MAX_LEN	32

struct hl_wait_cs_in {
	union {
		struct {
			/*
			 * In case of wait_cs holds the CS sequence number.
			 * In case of wait for multi CS hold a user pointer to
			 * an array of CS sequence numbers
			 */
			__u64 seq;
			/* Absolute timeout to wait for command submission
			 * in microseconds
			 */
			__u64 timeout_us;
		};

		struct {
			union {
				/* User address for completion comparison.
				 * upon interrupt, driver will compare the value pointed
				 * by this address with the supplied target value.
				 * in order not to perform any comparison, set address
				 * to all 1s.
				 * Relevant only when HL_WAIT_CS_FLAGS_INTERRUPT is set
				 */
				__u64 addr;

				/* cq_counters_handle to a kernel mapped cb which contains
				 * cq counters.
				 * Relevant only when HL_WAIT_CS_FLAGS_INTERRUPT_KERNEL_CQ is set
				 */
				__u64 cq_counters_handle;
			};

			/* Target value for completion comparison */
			__u64 target;
		};
	};

	/* Context ID - Currently not in use */
	__u32 ctx_id;

	/* HL_WAIT_CS_FLAGS_*
	 * If HL_WAIT_CS_FLAGS_INTERRUPT is set, this field should include
	 * interrupt id according to HL_WAIT_CS_FLAGS_INTERRUPT_MASK
	 *
	 * in order to wait for any CQ interrupt, set interrupt value to
	 * HL_WAIT_CS_FLAGS_ANY_CQ_INTERRUPT.
	 *
	 * in order to wait for any decoder interrupt, set interrupt value to
	 * HL_WAIT_CS_FLAGS_ANY_DEC_INTERRUPT.
	 */
	__u32 flags;

	union {
		struct {
			/* Multi CS API info- valid entries in multi-CS array */
			__u8 seq_arr_len;
			__u8 pad[7];
		};

		/* Absolute timeout to wait for an interrupt in microseconds.
		 * Relevant only when HL_WAIT_CS_FLAGS_INTERRUPT is set
		 */
		__u64 interrupt_timeout_us;
	};

	/*
	 * cq counter offset inside the counters cb pointed by cq_counters_handle above.
	 * upon interrupt, driver will compare the value pointed
	 * by this address (cq_counters_handle + cq_counters_offset)
	 * with the supplied target value.
	 * relevant only when HL_WAIT_CS_FLAGS_INTERRUPT_KERNEL_CQ is set
	 */
	__u64 cq_counters_offset;

	/*
	 * Timestamp_handle timestamps buffer handle.
	 * relevant only when HL_WAIT_CS_FLAGS_REGISTER_INTERRUPT is set
	 */
	__u64 timestamp_handle;

	/*
	 * Timestamp_offset is offset inside the timestamp buffer pointed by timestamp_handle above.
	 * upon interrupt, if the cq reached the target value then driver will write
	 * timestamp to this offset.
	 * relevant only when HL_WAIT_CS_FLAGS_REGISTER_INTERRUPT is set
	 */
	__u64 timestamp_offset;
};

#define HL_WAIT_CS_STATUS_COMPLETED	0
#define HL_WAIT_CS_STATUS_BUSY		1
#define HL_WAIT_CS_STATUS_TIMEDOUT	2
#define HL_WAIT_CS_STATUS_ABORTED	3

#define HL_WAIT_CS_STATUS_FLAG_GONE		0x1
#define HL_WAIT_CS_STATUS_FLAG_TIMESTAMP_VLD	0x2

struct hl_wait_cs_out {
	/* HL_WAIT_CS_STATUS_* */
	__u32 status;
	/* HL_WAIT_CS_STATUS_FLAG* */
	__u32 flags;
	/*
	 * valid only if HL_WAIT_CS_STATUS_FLAG_TIMESTAMP_VLD is set
	 * for wait_cs: timestamp of CS completion
	 * for wait_multi_cs: timestamp of FIRST CS completion
	 */
	__s64 timestamp_nsec;
	/* multi CS completion bitmap */
	__u32 cs_completion_map;
	__u32 pad;
};

union hl_wait_cs_args {
	struct hl_wait_cs_in in;
	struct hl_wait_cs_out out;
};

/* Opcode to allocate device memory */
#define HL_MEM_OP_ALLOC			0

/* Opcode to free previously allocated device memory */
#define HL_MEM_OP_FREE			1

/* Opcode to map host and device memory */
#define HL_MEM_OP_MAP			2

/* Opcode to unmap previously mapped host and device memory */
#define HL_MEM_OP_UNMAP			3

/* Opcode to map a hw block */
#define HL_MEM_OP_MAP_BLOCK		4

/* Opcode to create DMA-BUF object for an existing device memory allocation
 * and to export an FD of that DMA-BUF back to the caller
 */
#define HL_MEM_OP_EXPORT_DMABUF_FD	5

/* Opcode to create timestamps pool for user interrupts registration support
 * The memory will be allocated by the kernel driver, A timestamp buffer which the user
 * will get handle to it for mmap, and another internal buffer used by the
 * driver for registration management
 * The memory will be freed when the user closes the file descriptor(ctx close)
 */
#define HL_MEM_OP_TS_ALLOC		6


/* EXPERIMENTAL FEATURE!!!
 * =======================
 * Opcode to register a DMA-BUF object through its FD. The driver will attach
 * to the DMA-BUF object and will map the PCI BAR bus addresses to the
 * device's PMMU and will return a device VA to the user so it can use it
 * in DMA workloads
 */
#define HL_MEM_OP_REG_DMABUF_FD		99

/* Memory flags */
#define HL_MEM_CONTIGUOUS	0x1
#define HL_MEM_SHARED		0x2
#define HL_MEM_USERPTR		0x4
#define HL_MEM_FORCE_HINT	0x8
#define HL_MEM_ODP		0x20
#define HL_MEM_PREFETCH		0x40

/**
 * structure hl_mem_in - structure that handle input args for memory IOCTL
 * @union arg: union of structures to be used based on the input operation
 * @op: specify the requested memory operation (one of the HL_MEM_OP_* definitions).
 * @flags: flags for the memory operation (one of the HL_MEM_* definitions).
 *         For the HL_MEM_OP_EXPORT_DMABUF_FD opcode, this field holds the DMA-BUF file/FD flags.
 * @ctx_id: context ID - currently not in use.
 * @num_of_elements: number of timestamp elements used only with HL_MEM_OP_TS_ALLOC opcode.
 */
struct hl_mem_in {
	union {
		/**
		 * structure for device memory allocation (used with the HL_MEM_OP_ALLOC op)
		 * @mem_size: memory size to allocate
		 * @page_size: page size to use on allocation. when the value is 0 the default page
		 *             size will be taken.
		 */
		struct {
			__u64 mem_size;
			__u64 page_size;
		} alloc;

		/**
		 * structure for free-ing device memory (used with the HL_MEM_OP_FREE op)
		 * @handle: handle returned from HL_MEM_OP_ALLOC
		 */
		struct {
			__u64 handle;
		} free;

		/**
		 * structure for mapping device memory (used with the HL_MEM_OP_MAP op)
		 * @hint_addr: requested virtual address of mapped memory.
		 *             the driver will try to map the requested region to this hint
		 *             address, as long as the address is valid and not already mapped.
		 *             the user should check the returned address of the IOCTL to make
		 *             sure he got the hint address.
		 *             passing 0 here means that the driver will choose the address itself.
		 * @handle: handle returned from HL_MEM_OP_ALLOC.
		 */
		struct {
			__u64 hint_addr;
			__u64 handle;
		} map_device;

		/**
		 * structure for mapping host memory (used with the HL_MEM_OP_MAP op)
		 * @host_virt_addr: address of allocated host memory.
		 * @hint_addr: requested virtual address of mapped memory.
		 *             the driver will try to map the requested region to this hint
		 *             address, as long as the address is valid and not already mapped.
		 *             the user should check the returned address of the IOCTL to make
		 *             sure he got the hint address.
		 *             passing 0 here means that the driver will choose the address itself.
		 * @size: size of allocated host memory.
		 */
		struct {
			__u64 host_virt_addr;
			__u64 hint_addr;
			__u64 mem_size;
		} map_host;

		/**
		 * structure for mapping hw block (used with the HL_MEM_OP_MAP_BLOCK op)
		 * @block_addr:HW block address to map, a handle and size will be returned
		 *             to the user and will be used to mmap the relevant block.
		 *             only addresses from configuration space are allowed.
		 */
		struct {
			__u64 block_addr;
		} map_block;

		/**
		 * structure for unmapping host memory (used with the HL_MEM_OP_UNMAP op)
		 * @device_virt_addr: virtual address returned from HL_MEM_OP_MAP or
		 *                    from HL_MEM_OP_REG_DMABUF_FD
		 */
		struct {
			__u64 device_virt_addr;
		} unmap;

		/**
		 * structure for exporting DMABUF object (used with
		 * the HL_MEM_OP_EXPORT_DMABUF_FD op)
		 * @addr: for Gaudi1, the driver expects a physical address
		 *        inside the device's DRAM. this is because in Gaudi1
		 *        we don't have MMU that covers the device's DRAM.
		 *        for all other ASICs, the driver expects a device
		 *        virtual address that represents the start address of
		 *        a mapped DRAM memory area inside the device.
		 *        the address must be the same as was received from the
		 *        driver during a previous HL_MEM_OP_MAP operation.
		 * @mem_size: size of memory to export.
		 * @offset: for Gaudi1, this value must be 0. For all other ASICs,
		 *          the driver expects an offset inside of the memory area
		 *          describe by addr. the offset represents the start
		 *          address of that the exported dma-buf object describes.
		 */
		struct {
			__u64 addr;
			__u64 mem_size;
			__u64 offset;
		} export_dmabuf_fd;

		/**
		 * structure for registering DMABUF object (used with
		 * the HL_MEM_OP_REG_DMABUF_FD op)
		 * @fd: handle of DMA-BUF object to register.
		 * @length: total length of device memory area that the dmabuf object represents
		 */
		struct {
			__u64 fd;
			__u64 length;
		} reg_dmabuf_fd;
	};

	__u32 op;
	__u32 flags;
	__u32 ctx_id;
	__u32 num_of_elements;
};

struct hl_mem_out {
	union {
		/*
		 * Used for HL_MEM_OP_MAP and HL_MEM_OP_REG_DMABUF_FD as the
		 * virtual address that was assigned in the device VA space.
		 * A value of 0 means the requested operation failed.
		 */
		__u64 device_virt_addr;

		/*
		 * Used in HL_MEM_OP_ALLOC
		 * This is the assigned handle for the allocated memory
		 */
		__u64 handle;

		struct {
			/*
			 * Used in HL_MEM_OP_MAP_BLOCK.
			 * This is the assigned handle for the mapped block
			 */
			__u64 block_handle;

			/*
			 * Used in HL_MEM_OP_MAP_BLOCK
			 * This is the size of the mapped block
			 */
			__u32 block_size;

			__u32 pad;
		};

		/* Returned in HL_MEM_OP_EXPORT_DMABUF_FD. Represents the
		 * DMA-BUF object that was created to describe a memory
		 * allocation on the device's memory space. The FD should be
		 * passed to the importer driver
		 */
		__s32 fd;
	};
};

union hl_mem_args {
	struct hl_mem_in in;
	struct hl_mem_out out;
};

#define HL_DEBUG_MAX_AUX_VALUES		10
#define HL_DEBUG_MAX_READ_BLOCK_SIZE	(4 * PAGE_SIZE_4KB)

struct hl_debug_params_etr {
	/* Address in memory to allocate buffer */
	__u64 buffer_address;

	/* Size of buffer to allocate */
	__u64 buffer_size;

	/* Sink operation mode: SW fifo, HW fifo, Circular buffer */
	__u32 sink_mode;
	__u32 pad;
};

struct hl_debug_params_fetch_trace {
	/* Memory address to copy buffer to */
	__u64 buffer_address;

	/* Size of the buffer provided */
	__u64 buffer_size;

	/* Memory address to write buffer index to */
	__u64 buffer_index_address;

	/* Memory address to return number of copied bytes */
	__u64 copied_size_addr;

	/* Source ETR ID */
	__u32 etr_id;

	/* Timeout in miliseconds to wait for available buffer */
	__u32 timeout_ms;
};

#define HL_DEBUG_FETCH_STATUS_OK      0
#define HL_DEBUG_FETCH_STATUS_EMPTY   1 /* No available trace buffers */
#define HL_DEBUG_FETCH_STATUS_STOPPED 2 /* No available buffers and trace fetch has not started */

struct hl_debug_params_etf {
	/* Address in memory to allocate buffer */
	__u64 buffer_address;

	/* Size of buffer to allocate */
	__u64 buffer_size;

	/* Sink operation mode: SW fifo, HW fifo, Circular buffer */
	__u32 sink_mode;
	__u32 pad;
};

struct hl_debug_params_stm {
	/* Two bit masks for HW event and Stimulus Port */
	__u64 he_mask;
	__u64 sp_mask;

	/* Trace source ID */
	__u32 id;

	/* Frequency for the timestamp register */
	__u32 frequency;
};

struct hl_debug_params_bmon {
	/* Two address ranges that the user can request to filter */
	__u64 start_addr0;
	__u64 addr_mask0;

	__u64 start_addr1;
	__u64 addr_mask1;

	/* Capture window configuration */
	__u32 bw_win;
	__u32 win_capture;

	/* Trace source ID */
	__u32 id;

	/* Control register */
	__u32 control;

	/* Two more address ranges that the user can request to filter */
	__u64 start_addr2;
	__u64 end_addr2;

	__u64 start_addr3;
	__u64 end_addr3;
};

struct hl_debug_params_spmu {
	/* Event types selection */
	__u64 event_types[HL_DEBUG_MAX_AUX_VALUES];

	/* Number of event types selection */
	__u32 event_types_num;

	/* TRC configuration register values */
	__u32 pmtrc_val;
	__u32 trc_ctrl_host_val;
	__u32 trc_en_host_val;
};

struct hl_debug_params_mem_access {
	/* Start address in configuration space to write/read to/from */
	__u64 cfg_address;

	/* User address to copy data from/to */
	__u64 user_address;

	/* Size of data (4 bytes aligned). Max size is 64KB */
	__u32 size;

	/* Pad */
	__u32 reserved;
};

struct hl_debug_params_scheduler {
	/* Scheduler cpu ID */
	__u64 cpu_id;

	/* Queue ID */
	__u64 queue_id;

	/* Input/output buffer */
	__u64 buffer;

	/* Buffer size */
	__u32 size;

	/* Pad */
	__u32 reserved;
};

/**
 * struct hl_debug_params_read_block - structure to read device config memory block data
 * @cfg_address: start address in configuration space to read from
 * @user_address: user address of a buffer to copy the data
 * @size: the size of data to read (4 bytes aligned). Max size HL_DEBUG_MAX_READ_BLOCK_SIZE (16KB)
 * @flags: flags for the read operation
 */
struct hl_debug_params_read_block {
	__u64 cfg_address;
	__u64 user_address;
	__u32 size;
	__u32 flags;
};

/* Opcode for ETR component */
#define HL_DEBUG_OP_ETR		0
/* Opcode for ETF component */
#define HL_DEBUG_OP_ETF		1
/* Opcode for STM component */
#define HL_DEBUG_OP_STM		2
/* Opcode for FUNNEL component */
#define HL_DEBUG_OP_FUNNEL	3
/* Opcode for BMON component */
#define HL_DEBUG_OP_BMON	4
/* Opcode for SPMU component */
#define HL_DEBUG_OP_SPMU	5
/* Opcode for timestamp (deprecated) */
#define HL_DEBUG_OP_TIMESTAMP	6
/* Opcode for setting the device into or out of debug mode. The enable
 * variable should be 1 for enabling debug mode and 0 for disabling it
 */
#define HL_DEBUG_OP_SET_MODE	7
/* Opcode for fetching trace data */
#define HL_DEBUG_OP_FETCH_TRACE	8

/* Opcode for debug read memory */
#define HL_DEBUG_OP_READMEM	1024
/* Opcode for debug write to memory */
#define HL_DEBUG_OP_MEMCPY	1025
/* Opcode for submitting a buffer on a scheduler CCB */
#define HL_DEBUG_OP_SCHED_SUBMIT_BUF	1031
/* Opcode for debug read memory */
#define HL_DEBUG_OP_READBLOCK	1032
/* Opcode for re-enable capturing of error info */
#define HL_DEBUG_ENABLE_ERR_INFO_CAPTURE 1033

struct hl_debug_args {
	/*
	 * Pointer to user input structure.
	 * This field is relevant to specific opcodes.
	 */
	__u64 input_ptr;
	/* Pointer to user output structure */
	__u64 output_ptr;
	/* Size of user input structure */
	__u32 input_size;
	/* Size of user output structure */
	__u32 output_size;
	/* HL_DEBUG_OP_* */
	__u32 op;
	/*
	 * Register index in the component, taken from the debug_regs_index enum
	 * in the various ASIC header files
	 */
	__u32 reg_idx;
	/* Enable/disable */
	__u32 enable;
	/* Context ID - Currently not in use */
	__u32 ctx_id;
};

/* Requester */
#define HL_NIC_CQE_TYPE_REQ	0
/* Responder */
#define HL_NIC_CQE_TYPE_RES	1

/* Number of backpressure offsets */
#define HL_NIC_USER_BP_OFFS_MAX	16

/* Number of FnA addresses for SRAM/DCCM completion */
#define HL_NIC_FNA_CMPL_ADDR_NUM 2

/**
 * struct hl_nic_cqe: NIC CQ entry. This structure is shared between the driver and the user
 *                    application. It represents each entry of the NIC CQ buffer.
 * @requester.wqe_index: work queue index - for requester only.
 * @responder.msg_id: message ID to notify which receive action was completed - for responder only.
 * @qp_err.syndrome: error syndrome of the QP error - for QP error only.
 * @port: NIC port index of the related CQ.
 * @qp_number: QP number - for requester or QP error only.
 * @type: type of the CQE - requester or responder.
 * @is_err: true for QP error entry, false otherwise.
 */
struct hl_nic_cqe {
	union {
		struct {
			__u32 wqe_index;
		} requester;

		struct {
			__u32 msg_id;
		} responder;

		struct {
			__u32 syndrome;
		} qp_err;
	};

	__u32 port;
	__u32 qp_number;
	__u8 type;
	__u8 is_err;
	__u8 pad[2];
};

/**
 * struct hl_nic_alloc_conn_in - NIC ioctl opcode HL_NIC_OP_ALLOC_CONN in param
 * @port: NIC port ID
 * @hint: this may be used as the connection-number hint for the driver as a recommendation of user
 */
struct hl_nic_alloc_conn_in {
	__u32 port;
	__u32 hint;
};

/**
 * struct hl_nic_alloc_conn_out - NIC ioctl opcode HL_NIC_OP_ALLOC_CONN out param
 * @conn_id: Connection ID
 */
struct hl_nic_alloc_conn_out {
	__u32 conn_id;
	__u32 pad;
};

/**
 * struct hl_nic_req_conn_ctx_in - NIC ioctl opcode HL_NIC_OP_SET_REQ_CONN_CTX in param
 * @dst_ip_addr: Destination IP address in native endianness
 * @dst_conn_id: Destination connection ID
 * @last_index: Index of last entry [2..(2^22)-1]. NOTE: relevant for Gaudi1 (only)
 * @port: NIC port ID
 * @conn_id: Connection ID
 * @dst_mac_addr: Destination MAC address
 * @priority: Connection priority [0..3]
 * @timer_granularity: Timer granularity [0..127]
 * @swq_granularity: SWQ granularity [0 for 32B or 1 for 64B]
 * @wq_type: Work queue type [1..3]
 * @cq_number: Completion queue number
 * @wq_remote_log_size: Remote Work queue log size [2^QPC] Rendezvous
 * @congestion_en: Enable/disable Congestion-Control
 * @congestion_wnd: Congestion-Window size
 * @mtu: Max Transmit Unit
 * @encap_en: used as boolean; indicates if this QP has encapsulation support
 * @encap_id: Encapsulation-id; valid only if 'encap_en' is set
 * @wq_size: Max number of elements in the work queue. NOTE: relevant for Gaudi2 (or higher)
 * @loopback: used as boolean; indicates if this QP used for loopback mode.
 * @coll_lag_idx: (Gaudi3 and above) The index of the specific NIC within the LAG. Note that the
 *                advanced flag must be enabled in case it's being set.
 * @coll_last_in_lag: (Gaudi3 and above) Is the specific NIC the last one within the collective LAG.
 *                    Note that the advanced flag must be enabled in case it's being set.
 * @compression_en: Enable compression
 * @remote_key: Remote-key to be used to generate on outgoing packets
 * @sack_en: (Gaudi3 and above) Enable Selective Acknowledgment (SACK)
 * @coll_lag_size: (Fs1 and above) The collective LAG size (i.e. number of ports in this LAG)
 */
struct hl_nic_req_conn_ctx_in {
	__u32 reserved;
	__u32 dst_ip_addr;
	__u32 dst_conn_id;
	__u32 deprecated1;
	__u32 last_index;
	__u32 port;
	__u32 conn_id;
	__u8 dst_mac_addr[ETH_ALEN];
	__u8 deprecated2;
	__u8 priority;
	__u8 deprecated3;
	__u8 timer_granularity;
	__u8 swq_granularity;
	__u8 wq_type;
	__u8 deprecated4;
	__u8 cq_number;
	__u8 wq_remote_log_size;
	__u8 congestion_en;
	__u32 congestion_wnd;
	__u16 mtu;
	__u8 encap_en;
	__u8 encap_id;
	__u32 wq_size;
	__u8 loopback;
	__u8 coll_lag_idx;
	__u8 coll_last_in_lag;
	__u8 compression_en;
	__u32 remote_key;
	__u8 sack_en;
	__u8 coll_lag_size;
	__u8 pad[6];
};

/**
 * struct hl_nic_req_conn_ctx_out - NIC ioctl opcode HL_NIC_OP_SET_REQ_CONN_CTX out param
 * @swq_mem_handle: Handle for send WQ memory.
 * @rwq_mem_handle: Handle for receive WQ memory.
 * @swq_mem_size: Size of the send WQ memory.
 * @rwq_mem_size: Size of the receive WQ memory.
 */
struct hl_nic_req_conn_ctx_out {
	__u64 swq_mem_handle;
	__u64 rwq_mem_handle;
	__u32 swq_mem_size;
	__u32 rwq_mem_size;
};

/**
 * struct hl_nic_res_conn_ctx_in - NIC ioctl opcode HL_NIC_OP_SET_RES_CONN_CTX in param
 * @dst_ip_addr: Destination IP address in native endianness
 * @dst_conn_id: Destination connection ID
 * @port: NIC port ID
 * @conn_id: Connection ID
 * @dst_mac_addr: Destination MAC address
 * @priority: Connection priority [0..3]
 * @wq_peer_granularity: Work queue granularity
 * @cq_number: Completion queue number
 * @conn_peer: Connection peer
 * @rdv: used as boolean; indicates if this QP is RDV (WRITE or READ)
 * @loopback: used as boolean; indicates if this QP used for loopback mode.
 * @encap_en: used as boolean; indicates if this QP has encapsulation support
 * @encap_id: Encapsulation-id; valid only if 'encap_en' is set
 * @wq_peer_size: size of the peer Work queue
 * @local_key: Local-key to be used to validate against incoming packets
 * @sack_en: (Gaudi3 and above) Enable Selective Acknowlegment (SACK)
 */
struct hl_nic_res_conn_ctx_in {
	__u32 reserved;
	__u32 dst_ip_addr;
	__u32 dst_conn_id;
	__u32 port;
	__u32 conn_id;
	__u8 dst_mac_addr[ETH_ALEN];
	__u8 priority;
	__u8 deprecated1;
	__u8 deprecated2;
	__u8 wq_peer_granularity;
	__u8 cq_number;
	__u8 deprecated3;
	__u32 conn_peer;
	__u8 rdv;
	__u8 loopback;
	__u8 encap_en;
	__u8 encap_id;
	__u32 wq_peer_size;
	__u32 local_key;
	__u8 sack_en;
	__u8 pad[7];
};

/**
 * struct hl_nic_destroy_conn_in - NIC ioctl opcode HL_NIC_OP_DESTROY_CONN in param
 * @port: NIC port ID
 * @conn_id: Connection ID
 */
struct hl_nic_destroy_conn_in {
	__u32 port;
	__u32 conn_id;
};

/**
 * enum hl_nic_mem_type - NIC WQ memory allocation type
 * @HL_NIC_USER_WQ_SEND: Allocate memory for the user send WQ array
 * @HL_NIC_USER_WQ_RECV: Allocate memory for the user receive WQ array
 * @HL_NIC_USER_COLL_WQ_SEND: Allocate memory for the user collective send WQ array
 * @HL_NIC_USER_COLL_WQ_RECV: Allocate memory for the user collective receive WQ array
 * @HL_NIC_USER_COLL_SCALE_OUT_WQ_SEND: Allocate memory for the user scale-out collective send WQ
 *                                      array
 * @HL_NIC_USER_COLL_SCALE_OUT_WQ_RECV: Allocate memory for the user scale-out collective receive
 *                                      WQ array
 * @HL_NIC_USER_WQ_TYPE_MAX: number of values in enum
 */
enum hl_nic_mem_type {
	HL_NIC_USER_WQ_SEND,
	HL_NIC_USER_WQ_RECV,
	HL_NIC_USER_COLL_WQ_SEND,
	HL_NIC_USER_COLL_WQ_RECV,
	HL_NIC_USER_COLL_SCALE_OUT_WQ_SEND,
	HL_NIC_USER_COLL_SCALE_OUT_WQ_RECV,
	HL_NIC_USER_WQ_TYPE_MAX
};

/**
 * enum hl_nic_mem_id - Gaudi2 (or higher) memory allocation methods
 * @HL_NIC_MEM_HOST: memory allocated on the host memory
 * @HL_NIC_MEM_DEVICE: memory allocated on the device memory
 */
enum hl_nic_mem_id {
	HL_NIC_MEM_HOST = 1,
	HL_NIC_MEM_DEVICE
};

/**
 * enum hl_nic_swq_granularity - Gaudi2 (or higher) send WQE granularity
 * @HL_NIC_SWQE_GRAN_32B: 32 byte WQE for linear write
 * @HL_NIC_SWQE_GRAN_64B: 64 byte WQE for multi-stride write
 */
enum hl_nic_swq_granularity {
	HL_NIC_SWQE_GRAN_32B,
	HL_NIC_SWQE_GRAN_64B
};

/**
 * struct hl_nic_user_wq_arr_set_in - NIC ioctl opcode HL_NIC_OP_USER_WQ_SET in param
 * @addr: WQ array address, NOTE: relevant for Gaudi1 (only)
 * @port: NIC port ID
 * @num_of_wqs: Number of user WQs
 * @num_of_wq_entries: Number of entries per user WQ
 * @type: Type of user WQ array
 * @mem_id: Specify host/device memory allocation. NOTE: relevant for Gaudi2 (or higher)
 * @swq_granularity: Specify the granularity of send WQ, 0: 32 bytes, 1: 64 bytes
 */
struct hl_nic_user_wq_arr_set_in {
	__u64 addr;
	__u32 port;
	__u32 num_of_wqs;
	__u32 num_of_wq_entries;
	__u32 type;
	__u32 mem_id;
	__u8  swq_granularity;
	__u8  pad[3];
};

/**
 * struct hl_nic_user_wq_arr_set_out - NIC ioctl opcode HL_NIC_OP_USER_WQ_SET out param
 * @mem_handle: Handle of WQ array memory buffer
 */
struct hl_nic_user_wq_arr_set_out {
	__u64 mem_handle;
};

/**
 * struct hl_nic_user_wq_arr_unset_in - NIC ioctl opcode HL_NIC_OP_USER_WQ_UNSET in param
 * @port: NIC port ID
 * @type: Type of user WQ array
 */
struct hl_nic_user_wq_arr_unset_in {
	__u32 port;
	__u32 type;
};

/**
 * struct hl_nic_user_cq_set_in - NIC ioctl opcode HL_NIC_OP_USER_CQ_SET in param, relevant for
 *                                Gaudi only.
 * @addr: CQ buffer address.
 * @port: NIC port ID.
 * @num_of_cqes: Number of CQ entries in the buffer.
 */
struct hl_nic_user_cq_set_in {
	__u64 addr;
	__u32 port;
	__u32 num_of_cqes;
};

/**
 * struct hl_nic_user_cq_unset_in - NIC ioctl opcode HL_NIC_OP_USER_CQ_UNSET in param, relevant for
 *                                  Gaudi only.
 * @port: NIC port ID.
 */
struct hl_nic_user_cq_unset_in {
	__u32 port;
	__u32 pad;
};

/**
 * struct hl_nic_user_cq_update_ci_in - NIC ioctl opcode HL_NIC_OP_USER_CQ_UPDATE_CI in param,
 *                                      relevant for Gaudi only.
 * @port: NIC port ID.
 * @ci: Consumer index value to update.
 */
struct hl_nic_user_cq_update_ci_in {
	__u32 port;
	__u32 ci;
};

/**
 * struct hl_nic_alloc_user_cq_id_in - NIC ioctl opcode HL_NIC_OP_ALLOC_USER_CQ_ID in param,
 *                                     relevant for Gaudi2 (or higher).
 * @port: NIC port ID.
 */
struct hl_nic_alloc_user_cq_id_in {
	__u32 port;
	__u32 pad;
};

/**
 * struct hl_nic_alloc_user_cq_id_out - NIC ioctl opcode HL_NIC_OP_ALLOC_USER_CQ_ID out param,
 *                                      relevant for Gaudi2 (or higher).
 * @id: CQ ID.
 */
struct hl_nic_alloc_user_cq_id_out {
	__u32 id;
	__u32 pad;
};

/**
 * struct hl_nic_user_cq_id_set_in - NIC ioctl opcode HL_NIC_OP_USER_CQ_SET in param, relevant for
 *                                   Gaudi2 (or higher).
 * @port: NIC port ID.
 * @num_of_cqes: Number of CQ entries in the buffer.
 * @id: CQ ID.
 */
struct hl_nic_user_cq_id_set_in {
	__u32 port;
	__u32 num_of_cqes;
	__u32 id;
	__u32 pad;
};

/**
 * struct hl_nic_user_cq_id_set_out - NIC ioctl opcode HL_NIC_OP_USER_CQ_ID_SET out param, relevant
 *                                    for Gaudi2 (or higher).
 * @mem_handle: Handle of CQ memory buffer.
 * @pi_handle: Handle of CQ producer-inder memory buffer.
 * @regs_handle: Handle of CQ Registers base-address.
 * @regs_offset: CQ Registers sub-offset.
 */
struct hl_nic_user_cq_id_set_out {
	__u64 mem_handle;
	__u64 pi_handle;
	__u64 regs_handle;
	__u32 regs_offset;
	__u32 pad;
};

/**
 * struct hl_nic_user_cq_id_unset_in - NIC ioctl opcode HL_NIC_OP_USER_CQ_ID_UNSET in param,
 *                                     relevant for Gaudi2 (or higher).
 * @port: NIC port ID.
 * @id: NIC CQ ID.
 */
struct hl_nic_user_cq_id_unset_in {
	__u32 port;
	__u32 id;
};

/**
 * struct hl_nic_alloc_coll_conn_in - NIC ioctl opcode HL_NIC_OP_ALLOC_COLL_CONN in param,
 *                                    relevant for Gaudi3 (or higher).
 * @is_scale_out: Is this collective connection for scale out.
 */
struct hl_nic_alloc_coll_conn_in {
	__u8 is_scale_out;
	__u8 pad[7];
};

/**
 * struct hl_nic_alloc_coll_conn_out - NIC ioctl opcode HL_NIC_OP_ALLOC_COLL_CONN out param,
 *                                     relevant for Gaudi3 (or higher).
 * @conn_id: Connection ID.
 */
struct hl_nic_alloc_coll_conn_out {
	__u32 conn_id;
	__u32 pad;
};

/**
 * struct hl_nic_dump_qp_in - NIC ioctl opcode HL_NIC_OP_DUMP_QP in param.
 * @user_buf_address: Pre-allocated user buffer address to hold the dump output.
 * @user_buf_size: Size of the user buffer.
 * @port: NIC port ID.
 * @qpn: NIC QP ID.
 * @req: is requester (otherwise responder).
 */
struct hl_nic_dump_qp_in {
	__u64 user_buf;
	__u32 user_buf_size;
	__u32 port;
	__u32 qpn;
	__u8 req;
	__u8 pad[3];
};

/**
 * struct hl_nic_set_user_app_params_in - NIC ioctl opcode HL_NIC_OP_SET_USER_APP_PARAMS in param.
 *                                        allow the user application to set general parameters
 *                                        regarding the RDMA nic operation. These parameters stay
 *                                        in effect until the application releases the device
 * @port: NIC port ID
 * @bp_offs: Offsets in NIC memory to signal a back pressure. Note that the advanced flag
 *              must be enabled in case it's being set.
 * @advanced: A boolean that indicates whether this WQ should support advanced operations, such as
 *            RDV, QMan, WTD, etc.
 * @fna_mask_size: Completion address value mask.
 * @fna_fifo_offs: SRAM/DCCM addresses provided to the HW by the user when FnA completion is
 *		configured in the SRAM/DDCM.
 */
struct hl_nic_set_user_app_params_in {
	__u32 port;
	__u32 bp_offs[HL_NIC_USER_BP_OFFS_MAX];
	__u8 advanced;
	__u8 pad1;
	__u8 fna_mask_size;
	__u8 pad2;
	__u32 fna_fifo_offs[HL_NIC_FNA_CMPL_ADDR_NUM];
};

/**
 * struct hl_nic_get_user_app_params_in - NIC ioctl opcode HL_NIC_OP_GET_USER_APP_PARAMS in param
 * @port: NIC port ID
 */
struct hl_nic_get_user_app_params_in {
	__u32 port;
	__u8 pad[4];
};

/**
 * struct hl_nic_get_user_app_params_out - NIC ioctl opcode HL_NIC_OP_GET_USER_APP_PARAMS out param
 * @max_num_of_qps: Number of QPs that are supported by the driver. User must allocate enough room
 *                  for his work-queues according to this number.
 * @num_allocated_qps: Number of QPs that were already allocated (in use)
 * @max_allocated_qp_idx: The highest index of the allocated QPs (i.e. this is where the
 *                        driver may allocate its next QP).
 * @max_cq_size: Maximum size of a CQ buffer.
 * @advanced: true if advanced features are supported.
 * @max_num_of_cqs: Maximum number of CQs.
 * @max_num_of_db_fifos: Maximum number of DB-FIFOs.
 * @max_num_of_encaps: Maximum number of encapsulations.
 * @speed: port speed in Mbps.
 * @nic_macro_idx: macro index of this specific port.
 * @nic_phys_port_idx: physical port index (AKA lane) of this specific port.
 * @max_num_of_scale_out_coll_qps: Number of scale-out collective QPs that are supported by the
 *                                 driver. User must allocate enough room for his collective
 *                                 work-queues according to this number.
 * @max_num_of_coll_qps: Number of collective QPs that are supported by the driver. User must
 *                       allocate enough room for his collective work-queues according to this
 *                       number.
 * @coll_qps_offset: Specific port collective QPs index offset.
 * @base_scale_out_coll_qp_idx: The first scale-out collective QP id (common for all ports).
 * @base_coll_qp_idx: The first collective QP id (common for all ports).
 */
struct hl_nic_get_user_app_params_out {
	__u32 max_num_of_qps;
	__u32 num_allocated_qps;
	__u32 max_allocated_qp_idx;
	__u32 max_cq_size;
	__u8 advanced;
	__u8 max_num_of_cqs;
	__u8 max_num_of_db_fifos;
	__u8 max_num_of_encaps;
	__u32 speed;
	__u8 nic_macro_idx;
	__u8 nic_phys_port_idx;
	__u8 pad[2];
	__u32 max_num_of_scale_out_coll_qps;
	__u32 max_num_of_coll_qps;
	__u32 coll_qps_offset;
	__u32 base_scale_out_coll_qp_idx;
	__u32 base_coll_qp_idx;
};

/**
 * struct hl_nic_alloc_user_db_fifo_in - NIC ioctl opcode HL_NIC_OP_ALLOC_USER_DB_FIFO in param
 * @port: NIC port ID
 * @id_hint: Hint to allocate a specific HW resource
 */
struct hl_nic_alloc_user_db_fifo_in {
	__u32 port;
	__u32 id_hint;
};

/**
 * struct hl_nic_alloc_user_db_fifo_out - NIC ioctl opcode HL_NIC_OP_ALLOC_USER_DB_FIFO out param
 * @id: DB-FIFO ID
 */
struct hl_nic_alloc_user_db_fifo_out {
	__u32 id;
	__u32 pad;
};

/**
 * enum hl_nic_db_fifo_type - NIC users FIFO modes of operation.
 * @HL_NIC_DB_FIFO_TYPE_DB: (Gaudi2 and above) mode for direct user door-bell submit.
 * @HL_NIC_DB_FIFO_TYPE_CC: (Gaudi2 and above) mode for congestion control.
 * @HL_NIC_DB_FIFO_TYPE_COLL_OPS_SHORT: (Gaudi3 and above) mode for short collective operations.
 * @HL_NIC_DB_FIFO_TYPE_COLL_OPS_LONG: (Gaudi3 and above) mode for long collective operations.
 * @HL_NIC_DB_FIFO_TYPE_DWQ_LIN: (Gaudi3 and above) mode for linear direct WQE submit.
 * @HL_NIC_DB_FIFO_TYPE_DWQ_MS: (Gaudi3 and above) mode for multi-stride WQE submit.
 * @HL_NIC_DB_FIFO_TYPE_COLL_DIR_OPS_SHORT: (Gaudi3 and above) mode for direct short collective
 *                                                             operations.
 * @HL_NIC_DB_FIFO_TYPE_COLL_DIR_OPS_LONG: (Gaudi3 and above) mode for direct long collective
 *                                                             operations.
 */
enum hl_nic_db_fifo_type {
	HL_NIC_DB_FIFO_TYPE_DB = 0,
	HL_NIC_DB_FIFO_TYPE_CC,
	HL_NIC_DB_FIFO_TYPE_COLL_OPS_SHORT,
	HL_NIC_DB_FIFO_TYPE_COLL_OPS_LONG,
	HL_NIC_DB_FIFO_TYPE_DWQ_LIN,
	HL_NIC_DB_FIFO_TYPE_DWQ_MS,
	HL_NIC_DB_FIFO_TYPE_COLL_DIR_OPS_SHORT,
	HL_NIC_DB_FIFO_TYPE_COLL_DIR_OPS_LONG,
};

/**
 * struct hl_nic_user_db_fifo_set_in - NIC ioctl opcode HL_NIC_OP_USER_DB_FIFO_SET in param
 * @port: NIC port ID
 * @id: NIC DB-FIFO ID
 * @mode: represents desired mode of operation for provided FIFO, according to hl_nic_db_fifo_type
 * @dir_dup_ports_mask: ports for which the hw should duplicate the direct patcher descriptor
 *                                                                              (gaudi3 & above)
 * @base_sob_addr: base address of the sync object (gaudi3 & above)
 * @num_sobs: number of sync objects (gaudi3 & above)
 */
struct hl_nic_user_db_fifo_set_in {
	__u32 port;
	__u32 id;
	__u8 mode;
	__u8 dir_dup_ports_mask;
	__u8 pad[6];
	__u32 base_sob_addr;
	__u32 num_sobs;
};

/**
 * struct hl_nic_user_db_fifo_set_out - NIC ioctl opcode HL_NIC_OP_USER_DB_FIFO_SET out param
 * @ci_handle: Handle of DB-FIFO consumer-inder memory buffer
 * @regs_handle: Handle of DB-FIFO Registers base-address
 * @regs_offset: Offset to the DB-FIFO Registers
 * @fifo_size: fifo size that was allocated
 * @fifo_bp_thresh: fifo threshold that was set by the driver
 */
struct hl_nic_user_db_fifo_set_out {
	__u64 ci_handle;
	__u64 regs_handle;
	__u32 regs_offset;
	__u32 pad;
	__u32 fifo_size;
	__u32 fifo_bp_thresh;
};

/**
 * struct hl_nic_user_db_fifo_unset_in - NIC ioctl opcode HL_NIC_OP_USER_DB_FIFO_UNSET in param
 * @port: NIC port ID
 * @id: NIC DB-FIFO ID
 */
struct hl_nic_user_db_fifo_unset_in {
	__u32 port;
	__u32 id;
};

/* The operation completed successfully and an event was read */
#define HL_NIC_EQ_POLL_STATUS_SUCCESS			0
/* The operation completed successfully, no event was found */
#define HL_NIC_EQ_POLL_STATUS_EQ_EMPTY			1
/* The operation failed since it is not supported by the device/driver */
#define HL_NIC_EQ_POLL_STATUS_ERR_UNSUPPORTED_OP	2
/* The operation failed, port was not found */
#define HL_NIC_EQ_POLL_STATUS_ERR_NO_SUCH_PORT		3
/* The operation failed, port is disabled */
#define HL_NIC_EQ_POLL_STATUS_ERR_PORT_DISABLED		4
/* The operation failed, an event-queue associated with the app was not found */
#define HL_NIC_EQ_POLL_STATUS_ERR_NO_SUCH_EQ		5
/* The operation failed with an undefined error */
#define HL_NIC_EQ_POLL_STATUS_ERR_UNDEF			6

/* completion-queue events */
#define HL_NIC_EQ_EVENT_TYPE_CQ_ERR 0
/* Queue-pair events */
#define HL_NIC_EQ_EVENT_TYPE_QP_ERR 1
/* Doorbell events */
#define HL_NIC_EQ_EVENT_TYPE_DB_FIFO_ERR 2
/* congestion completion-queue events */
#define HL_NIC_EQ_EVENT_TYPE_CCQ 3
/* Direct WQE security error. */
#define HL_NIC_EQ_EVENT_TYPE_WTD_SECURITY_ERR 4
/* Numerical error */
#define HL_NIC_EQ_EVENT_TYPE_NUMERICAL_ERR 5
/* Link status. */
#define HL_NIC_EQ_EVENT_TYPE_LINK_STATUS 6
/* Queue-pair counters aligned */
#define HL_NIC_EQ_EVENT_TYPE_QP_ALIGN_COUNTERS 7

/**
 * struct hl_nic_eq_poll_in - NIC ioctl opcode HL_NIC_OP_EQ_POLL in param
 * @port: NIC port ID
 */
struct hl_nic_eq_poll_in {
	__u32 port;
	__u32 pad;
};

/**
 * struct hl_nic_eq_poll_out - NIC ioctl opcode HL_NIC_OP_EQ_POLL out param
 * @status: HL_NIC_EQ_POLL_STATUS_*
 * @idx: Connection/CQ/DB-fifo index, depends on event type
 * @ev_data: Event-specific data
 * @ev_type: Event type
 * @rest_occurred: Was the error due to reset
 * @is_req: For QP events marks if corresponding QP is requestor
 */
struct hl_nic_eq_poll_out {
	__u32 status;
	__u32 idx;
	__u32 ev_data;
	__u8 ev_type;
	__u8 rest_occurred;
	__u8 is_req;
	__u8 pad;
};

/**
 * enum hl_nic_encap_type - Supported encapsulation types
 * @HL_NIC_ENCAP_NONE: No Tunneling.
 * @HL_NIC_ENCAP_OVER_IPV4: Tunnel RDMA packets through L3 layer
 * @HL_NIC_ENCAP_OVER_UDP: Tunnel RDMA packets through L4 layer
 */
enum hl_nic_encap_type {
	HL_NIC_ENCAP_NONE,
	HL_NIC_ENCAP_OVER_IPV4,
	HL_NIC_ENCAP_OVER_UDP,
};

/**
 * struct hl_nic_user_encap_alloc_in - NIC ioctl opcode HL_NIC_OP_USER_ENCAP_ALLOC in param
 * @port: NIC port ID
 */
struct hl_nic_user_encap_alloc_in {
	__u32 port;
	__u32 pad;
};

/**
 * struct hl_nic_user_encap_alloc_out - NIC ioctl opcode HL_NIC_OP_USER_ENCAP_ALLOC out param
 * @id: Encapsulation ID
 */
struct hl_nic_user_encap_alloc_out {
	__u32 id;
	__u32 pad;
};

/**
 * struct hl_nic_user_encap_set_in - NIC ioctl opcode HL_NIC_OP_USER_ENCAP_SET in param
 * @tnl_hdr_ptr: Pointer to the tunnel encapsulation header. i.e. specific tunnel header data to be
 *               used in the encapsulation by the HW.
 * @tnl_hdr_size: Tunnel encapsulation header size.
 * @port: NIC port ID
 * @id: Encapsulation ID
 * @ipv4_addr: Source IP address, set regardless of encapsulation type.
 * @udp_dst_port: The UDP destination-port. Valid for L4 tunnel.
 * @ip_proto: IP protocol to use. Valid for L3 tunnel.
 * @encap_type: Encapsulation type. May be either no-encapsulation or encapsulation over L3 or L4.
 */
struct hl_nic_user_encap_set_in {
	__u64 tnl_hdr_ptr;
	__u32 tnl_hdr_size;
	__u32 port;
	__u32 id;
	__u32 ipv4_addr;
	union {
		__u16 udp_dst_port;
		__u16 ip_proto;
	};
	__u8 encap_type;
	__u8 pad[5];
};

/**
 * struct hl_nic_user_encap_unset_in - NIC ioctl opcode HL_NIC_OP_USER_ENCAP_UNSET in param
 * @port: NIC port ID
 * @id: Encapsulation ID
 */
struct hl_nic_user_encap_unset_in {
	__u32 port;
	__u32 id;
};

/**
 * struct hl_nic_user_ccq_set_in - NIC ioctl opcode HL_NIC_OP_USER_CCQ_SET in param
 * @port: NIC port ID
 * @num_of_entries: Number of CCQ entries in the buffer
 */
struct hl_nic_user_ccq_set_in {
	__u32 port;
	__u32 num_of_entries;
};

/**
 * struct hl_nic_user_ccq_set_out - NIC ioctl opcode HL_NIC_OP_USER_CCQ_SET out param
 * @mem_handle: Handle of CCQ memory buffer
 * @pi_handle: Handle of CCQ producer-index memory buffer
 * @id: CQ ID.
 */
struct hl_nic_user_ccq_set_out {
	__u64 mem_handle;
	__u64 pi_handle;
	__u32 id;
	__u32 pad;
};

/**
 * struct hl_nic_user_ccq_unset_in - NIC ioctl opcode HL_NIC_OP_USER_CCQ_UNSET in param
 * @port: NIC port ID
 */
struct hl_nic_user_ccq_unset_in {
	__u32 port;
	__u32 pad;
};

/* Opcode to allocate connection ID */
#define HL_NIC_OP_ALLOC_CONN			0
/* Opcode to set up a requester connection context */
#define HL_NIC_OP_SET_REQ_CONN_CTX		1
/* Opcode to set up a responder connection context */
#define HL_NIC_OP_SET_RES_CONN_CTX		2
/* Opcode to destroy a connection */
#define HL_NIC_OP_DESTROY_CONN			3
/* Opcode to create a CQ (deprecated) */
#define HL_NIC_OP_CQ_CREATE			4
/* Opcode to destroy a CQ (deprecated) */
#define HL_NIC_OP_CQ_DESTROY			5
/* Opcode to wait on CQ (deprecated) */
#define HL_NIC_OP_CQ_WAIT			6
/* Opcode to poll on CQ (deprecated) */
#define HL_NIC_OP_CQ_POLL			7
/* Opcode to update the number of consumed CQ entries (deprecated) */
#define HL_NIC_OP_CQ_UPDATE_CONSUMED_CQES	8
/* Opcode to set a user WQ array */
#define HL_NIC_OP_USER_WQ_SET			9
/* Opcode to unset a user WQ array */
#define HL_NIC_OP_USER_WQ_UNSET			10
/* Opcode to set user CQ; relevant for Gaudi only */
#define HL_NIC_OP_USER_CQ_SET			11
/* Opcode to unset user CQ; relevant for Gaudi only */
#define HL_NIC_OP_USER_CQ_UNSET			12
/* Opcode to update the user CQ consumer index; relevant for Gaudi only */
#define HL_NIC_OP_USER_CQ_UPDATE_CI		13
/* Opcode to allocate a CQ; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_ALLOC_USER_CQ_ID		14
/* Opcode to set specific user-application parameters
 * relevant for Gaudi2 (or higher)
 */
#define HL_NIC_OP_SET_USER_APP_PARAMS		15
/* Opcode to get specific user-application parameters
 * relevant for Gaudi2 (or higher)
 */
#define HL_NIC_OP_GET_USER_APP_PARAMS		16
/* Opcode to allocate a DB-FIFO; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_ALLOC_USER_DB_FIFO		17
/* Opcode to create a DB-FIFO; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_DB_FIFO_SET		18
/* Opcode to destroy a DB-FIFO; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_DB_FIFO_UNSET		19
/* Opcode to poll on EQ; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_EQ_POLL			20
/* Opcode to allocate encapsulation ID; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_ENCAP_ALLOC		21
/* Opcode to create an encapsulation; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_ENCAP_SET		22
/* Opcode to destroy an encapsulation; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_ENCAP_UNSET		23
/* Opcode to create a CCQ; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_CCQ_SET			24
/* Opcode to destroy a CCQ; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_CCQ_UNSET		25
/* Opcode to set user CQ by ID; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_CQ_ID_SET		26
/* Opcode to unset user CQ by ID; relevant for Gaudi2 (or higher) */
#define HL_NIC_OP_USER_CQ_ID_UNSET		27
/* Opcode to allocate collective connection ID; relevant for Gaudi3 (or higher) */
#define HL_NIC_OP_ALLOC_COLL_CONN		28
/* Opcode to dump the context of a QP */
#define HL_NIC_OP_DUMP_QP			29

/**
 * struct hl_nic_args - This structure is used as the arguments container for DRM_IOCTL_HL_NIC IOCTL
 * @input_ptr: Pointer to user input structure (relevant to specific opcodes)
 * @output_ptr: Pointer to user output structure (relevant to specific opcodes)
 * @input_size: Size of user input structure
 * @output_size: Size of user output structure
 * @ctx_id: Context ID - Currently not in use
 * @op: HL_NIC_OP_*
 */
struct hl_nic_args {
	__u64 input_ptr;
	__u64 output_ptr;
	__u32 input_size;
	__u32 output_size;
	__u32 ctx_id;
	__u32 op;
};

#define HL_IOCTL_INFO		0x00
#define HL_IOCTL_CB		0x01
#define HL_IOCTL_CS		0x02
#define HL_IOCTL_WAIT_CS	0x03
#define HL_IOCTL_MEMORY		0x04
#define HL_IOCTL_DEBUG		0x05
#define HL_IOCTL_NIC		0x06

/*
 * Various information operations such as:
 * - H/W IP information
 * - Current dram usage
 *
 * The user calls this IOCTL with an opcode that describes the required
 * information. The user should supply a pointer to a user-allocated memory
 * chunk, which will be filled by the driver with the requested information.
 *
 * The user supplies the maximum amount of size to copy into the user's memory,
 * in order to prevent data corruption in case of differences between the
 * definitions of structures in kernel and userspace, e.g. in case of old
 * userspace and new kernel driver
 */
#define DRM_IOCTL_HL_INFO	DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_INFO, struct hl_info_args)

/*
 * Command Buffer
 * - Request a Command Buffer
 * - Destroy a Command Buffer
 *
 * The command buffers are memory blocks that reside in DMA-able address
 * space and are physically contiguous so they can be accessed by the device
 * directly. They are allocated using the coherent DMA API.
 *
 * When creating a new CB, the IOCTL returns a handle of it, and the user-space
 * process needs to use that handle to mmap the buffer so it can access them.
 *
 * In some instances, the device must access the command buffer through the
 * device's MMU, and thus its memory should be mapped. In these cases, user can
 * indicate the driver that such a mapping is required.
 * The resulting device virtual address will be used internally by the driver,
 * and won't be returned to user.
 *
 */
#define DRM_IOCTL_HL_CB		DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_CB, union hl_cb_args)

/*
 * Command Submission
 *
 * To submit work to the device, the user need to call this IOCTL with a set
 * of JOBS. That set of JOBS constitutes a CS object.
 * Each JOB will be enqueued on a specific queue, according to the user's input.
 * There can be more then one JOB per queue.
 *
 * The CS IOCTL will receive two sets of JOBS. One set is for "restore" phase
 * and a second set is for "execution" phase.
 * The JOBS on the "restore" phase are enqueued only after context-switch
 * (or if its the first CS for this context). The user can also order the
 * driver to run the "restore" phase explicitly
 *
 * Goya/Gaudi:
 * There are two types of queues - external and internal. External queues
 * are DMA queues which transfer data from/to the Host. All other queues are
 * internal. The driver will get completion notifications from the device only
 * on JOBS which are enqueued in the external queues.
 *
 * Gaudi2 onwards:
 * There is a single type of queue for all types of engines, either DMA engines
 * for transfers from/to the host or inside the device, or compute engines.
 * The driver will get completion notifications from the device for all queues.
 *
 * For jobs on external queues, the user needs to create command buffers
 * through the CB ioctl and give the CB's handle to the CS ioctl. For jobs on
 * internal queues, the user needs to prepare a "command buffer" with packets
 * on either the device SRAM/DRAM or the host, and give the device address of
 * that buffer to the CS ioctl.
 * For jobs on H/W queues both options of command buffers are valid.
 *
 * This IOCTL is asynchronous in regard to the actual execution of the CS. This
 * means it returns immediately after ALL the JOBS were enqueued on their
 * relevant queues. Therefore, the user mustn't assume the CS has been completed
 * or has even started to execute.
 *
 * Upon successful enqueue, the IOCTL returns a sequence number which the user
 * can use with the "Wait for CS" IOCTL to check whether the handle's CS
 * non-internal JOBS have been completed. Note that if the CS has internal JOBS
 * which can execute AFTER the external JOBS have finished, the driver might
 * report that the CS has finished executing BEFORE the internal JOBS have
 * actually finished executing.
 *
 * Even though the sequence number increments per CS, the user can NOT
 * automatically assume that if CS with sequence number N finished, then CS
 * with sequence number N-1 also finished. The user can make this assumption if
 * and only if CS N and CS N-1 are exactly the same (same CBs for the same
 * queues).
 */
#define DRM_IOCTL_HL_CS		DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_CS, union hl_cs_args)

/*
 * Wait for Command Submission
 *
 * The user can call this IOCTL with a handle it received from the CS IOCTL
 * to wait until the handle's CS has finished executing. The user will wait
 * inside the kernel until the CS has finished or until the user-requested
 * timeout has expired.
 *
 * If the timeout value is 0, the driver won't sleep at all. It will check
 * the status of the CS and return immediately
 *
 * The return value of the IOCTL is a standard Linux error code. The possible
 * values are:
 *
 * EINTR     - Kernel waiting has been interrupted, e.g. due to OS signal
 *             that the user process received
 * ETIMEDOUT - The CS has caused a timeout on the device
 * EIO       - The CS was aborted (usually because the device was reset)
 * ENODEV    - The device wants to do hard-reset (so user need to close FD)
 *
 * The driver also returns a custom define in case the IOCTL call returned 0.
 * The define can be one of the following:
 *
 * HL_WAIT_CS_STATUS_COMPLETED   - The CS has been completed successfully (0)
 * HL_WAIT_CS_STATUS_BUSY        - The CS is still executing (0)
 * HL_WAIT_CS_STATUS_TIMEDOUT    - The CS has caused a timeout on the device
 *                                 (ETIMEDOUT)
 * HL_WAIT_CS_STATUS_ABORTED     - The CS was aborted, usually because the
 *                                 device was reset (EIO)
 */
#define DRM_IOCTL_HL_WAIT_CS	DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_WAIT_CS, union hl_wait_cs_args)

/*
 * Memory
 * - Map host memory to device MMU
 * - Unmap host memory from device MMU
 *
 * This IOCTL allows the user to map host memory to the device MMU
 *
 * For host memory, the IOCTL doesn't allocate memory. The user is supposed
 * to allocate the memory in user-space (malloc/new). The driver pins the
 * physical pages (up to the allowed limit by the OS), assigns a virtual
 * address in the device VA space and initializes the device MMU.
 *
 * There is an option for the user to specify the requested virtual address.
 *
 */
#define DRM_IOCTL_HL_MEMORY	DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_MEMORY, union hl_mem_args)

/*
 * Debug
 * - Enable/disable the ETR/ETF/FUNNEL/STM/BMON/SPMU debug traces
 *
 * This IOCTL allows the user to get debug traces from the chip.
 *
 * Before the user can send configuration requests of the various
 * debug/profile engines, it needs to set the device into debug mode.
 * This is because the debug/profile infrastructure is shared component in the
 * device and we can't allow multiple users to access it at the same time.
 *
 * Once a user set the device into debug mode, the driver won't allow other
 * users to "work" with the device, i.e. open a FD. If there are multiple users
 * opened on the device, the driver won't allow any user to debug the device.
 *
 * For each configuration request, the user needs to provide the register index
 * and essential data such as buffer address and size.
 *
 * Once the user has finished using the debug/profile engines, he should
 * set the device into non-debug mode, i.e. disable debug mode.
 *
 * The driver can decide to "kick out" the user if he abuses this interface.
 *
 */
#define DRM_IOCTL_HL_DEBUG	DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_DEBUG, struct hl_debug_args)

/*
 * NIC
 *
 * This IOCTL allows the user to manage and configure the device's NIC ports.
 * The following operations are available:
 * - Allocate connection ID
 * - Set up a requester connection context
 * - Set up a responder connection context
 * - Destroy a connection
 * - Create a completion queue
 * - Destroy a completion queue
 * - Wait on completion queue
 * - Poll a completion queue
 * - Update consumed completion queue entries
 * - Set a work queue
 * - Unset a work queue
 * - Set a user completion queue
 * - Unset a user completion queue
 * - Update user completion queue consumer index
 *
 * For all operations, the user should provide a pointer to an input structure
 * with the context parameters. Some of the operations also require a pointer to
 * an output structure for result/status.
 * The CQ create operation returns a handle which the user-space process needs
 * to use to mmap the CQ buffer in order to access the CQ entries.
 * This handle should be provided when destroying the CQ.
 * The poll/wait CQ operations return the number of available CQ entries of type
 * struct hl_nic_cqe.
 * Since the CQ is a cyclic buffer, the user-space process needs to inform the
 * driver regarding how many of the available CQEs were actually
 * processed/consumed. Only then the driver will override them with newer
 * entries.
 * The set WQ operation should provide the device virtual address of the WQ with
 * a matching size for the number of WQs and entries per WQ.
 * While in legacy CQ, the driver polls on the CQ buffers to fetch CQEs and
 * copies them to the user buffer, in user CQ the user polls on the CQ buffers
 * directly and handles the CQEs with zero-copy.
 * As in legacy CQ, also in user CQ, the user needs to inform the HW regarding
 * the updated consumer index so new CQEs will be able to be pushed to the
 * buffers.
 *
 */
#define DRM_IOCTL_HL_NIC	DRM_IOWR(DRM_COMMAND_BASE + HL_IOCTL_NIC, struct hl_nic_args)

#define HL_COMMAND_START	(DRM_COMMAND_BASE + HL_IOCTL_INFO)
#define HL_COMMAND_END		(DRM_COMMAND_BASE + HL_IOCTL_NIC + 1)

#endif /* HABANALABS_H_ */
